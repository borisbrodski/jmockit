<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
</head>
<body>
<h2>An example</h2>

<p>
   Say you have a business domain layer class (a "service" class) with a business operation which
   does two things through separate dependencies:
   a) it accesses a database using a static facade to the persistence subsystem (assume the
   transaction is demarcated at the appropriate point up in the call stack);
   and b) it calls a business method in another service class.
</p>
<pre><code>   public final class ServiceA
   {
      public void doBusinessOperationXyz(EntityX data) throws InvalidItemStatus
      {
(1)      List items = Database.find(
            "select item from EntityY item where item.someProperty=?",
            data.getSomeProperty());

(2)      BigDecimal total = new ServiceB().computeTotal(items);

         data.setTotal(total);
(3)      Database.save(data);
      }
   }

   public final class ServiceB
   {
      public BigDecimal computeTotal(List items) throws InvalidItemStatus
      {
         BigDecimal total = new BigDecimal(0);
         // compute total while iterating items, or throws InvalidItemStatus exception
         return total;
      }
   }
</code></pre>
<p>
   The <code>Database</code> class contains only static methods and a private
   constructor; the <code>find</code> and <code>save</code> methods should be obvious, so we won't
   list them here (assume they are implemented on top of an ORM API, such as Hibernate or JPA).
</p>
<p>
   So, how can we unit test the "doBusinessOperationXyz" method without making any changes to the
   existing application code?
   JMockit actually provides three different APIs that can be used, each capable enough for our
   needs. We will see how to use each one of them, starting with the most elegant.
   In all three cases, a JUnit test case will mock out the three dependencies of the method under
   test, that is, the method calls at <code>(1)</code>, <code>(2)</code>, and <code>(3)</code>.
</p>
<p>
   First, lets use the <strong>JMockit Expectations</strong> API.
</p>
<pre id="expectations"><code>   package jmockit.tutorial.domain;

   import java.math.*;
   import java.util.*;

   import static org.junit.Assert.*;
   import org.junit.*;
   import org.junit.runner.*;

   import mockit.*;
   import mockit.integration.junit4.*;

   import jmockit.tutorial.infrastructure.*;

   @RunWith(JMockit.class)
   public final class ServiceA_ExpectationsAPI_Test
   {
      @Mocked private final Database unused = null;
      @Mocked private ServiceB serviceB;

      @Test
      public void doBusinessOperationXyz() throws Exception
      {
         final EntityX data = new EntityX(5, "abc", "5453-1");
         final BigDecimal total = new BigDecimal("125.40");

         new Expectations()
         {
            {
               List&lt;?> items = new ArrayList&lt;Object>();
(1)            Database.find(withSubstring("select"), null); returns(items);

(2)            new ServiceB().computeTotal(items); returns(total);
(3)            Database.save(data);
            }
         };

         new ServiceA().doBusinessOperationXyz(data);

         assertEquals(total, data.getTotal());
      }

      @Test(expected = InvalidItemStatus.class)
      public void doBusinessOperationXyzWithInvalidItemStatus() throws Exception
      {
         new Expectations()
         {
            {
(1)            Database.find(anyString, anyString);

(2)            new ServiceB().computeTotal((List&lt;?>) withNotNull());
               throwsException(new InvalidItemStatus());
            }
         };

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);
      }
   }
</code></pre>
<p>
   First of all, note that <em>what</em> gets mocked is specified through <em>mock fields</em>,
   which are annotated as <code>@Mocked</code> (actually, all non-private fields
   in a subclass of <code>Expectations</code> are considered for mocking).
   <br/>
   A mock field can be of any reference type: an interface, abstract class, final/non-final class,
   or a class with private constructors only.
   <br/>
   By default, all members of a class or interface used as the type for a mock field will be mocked.
   Specific methods and constructors can be selected to be mocked or not through regular
   expressions provided as an attribute of the annotation. This annotation has a few other
   attributes and capabilities which we won't discuss at this point. Check the Javadoc documentation
   for more.
   <br/>
   Other mocking tools usually require a call to some mock creation method, which always returns a
   new object which later needs to be passed to the code under test. In JMockit, such instances may
   be passed to code under test, but don't have to be. In fact, no instance may be used at all, like
   with the <code>final Database unused = null</code> mock field in the previous
   tests.
   For non-<code>final</code> mock fields, JMockit will create and assign an appropriate mock
   instance.
</p>
<p>
   JMockit switches automatically from the <em>expectations recording phase</em> to the
   <em>replay phase</em> at the end of the <em>expectations block</em>.
   In EasyMock, a call to <code>replay(mock)</code> is needed for each mock used in the test to make
   this switch.
   In jMock there is also a phase switching method, which takes the form of a call to the
   <code>Mockery#checking(...)</code> method with a new instance of an anonymous
   <code>org.jmock.Expectations</code> subclass.
</p>
<p>
   Expected invocations are recorded simply by calling the desired methods or constructors.
   An expected return value can be specified through a call to <code>returns(...)</code>.
   Similarly, an expected exception is recorded with <code>throwsException(...)</code>. (For errors,
   it would be <code>throwsError(...)</code>.)
</p>
<p>
   JMockit automatically verifies all <em>strict</em> expectations (those recorded inside an
   <code>Expectations</code> block) before the end of the test.
   (As we will see below, <em>non-strict</em> expectations recorded inside a
   <code>NonStrictExpectations</code> block, on the other hand, must be verified
   explicitly inside <code>Verifications</code> blocks.)
   In EasyMock it is necessary to explicitly call <code>verify(mock)</code> for each mock used in
   the test.
   jMock also automatically performs an equivalent verification at the end of each test, as long as
   you specify <code>@RunWith(JMock.class)</code> for the test class.
   The similar <code>@RunWith(JMockit.class)</code> in JMockit isn't strictly required, though.
</p>
<p>
   The method calls <code>withXyz(...)</code>, as well as the field accesses <code>anyAbc</code> use
   <em>Hamcrest matchers</em> for flexible argument matching.
   Otherwise, an exact match is expected between recorded argument values and the corresponding
   values received in the replay phase.
</p>
<p>
   There is more to the Expectations API, about which you can find in the Javadoc documentation,
   and also in the many additional sample tests inside the full distribution.
</p>
<p>
   Up to this point we focused on <em>strict</em> expectations, that is, those that when recorded
   <em>must</em> be executed by the code under test in the same order; additionally, only explicitly
   recorded invocations are allowed to execute (any other invocation to a mock in the replay phase
   will be considered <em>unexpected</em>, causing the test to fail).
   Lets now consider testing with <em>non-strict</em> expectations, and the use of the
   <strong>JMockit Verifications</strong> API.
</p>

<pre id="verifications"><code>   package jmockit.tutorial.domain;

   import java.util.*;

   import org.junit.*;

   import mockit.*;
   import mockit.integration.junit4.*;

   import jmockit.tutorial.infrastructure.*;

   public final class ServiceA_VerificationsAPI_Test extends JMockitTest
   {
      @Mocked private final Database onlyStatics = null;
      @Mocked private final ServiceB unused = null;

      @Test
      public void doBusinessOperationXyzSavesData() throws Exception
      {
         final EntityX data = new EntityX(5, "abc", "5453-1");

         // No expectations in this case.

         new ServiceA().doBusinessOperationXyz(data);

         new Verifications()
         {
(3)         { Database.save(data); }
         };
      }

      @Test
      public void doBusinessOperationXyzFindsItemsAndComputesTotal() throws Exception
      {
         EntityX data = new EntityX(5, "abc", "5453-1");
         final List&lt;?> items = Arrays.asList(1, 2, 3);

         // Invocations that produce a result are recorded, but only those we care about.
         new NonStrictExpectations()
         {
            {
(1)            Database.find(withSubstring("select"), withAny("")); returns(items);
            }
         };

         new ServiceA().doBusinessOperationXyz(data);

         new Verifications()
         {
            {
(2)            new ServiceB().computeTotal(items);
            }
         };
      }

      @Test(expected = InvalidItemStatus.class)
      public void doBusinessOperationXyzWithInvalidItemStatus() throws Exception
      {
         new NonStrictExpectations()
         {
            {
(2)            new ServiceB().computeTotal((List&lt;?>) withNotNull());
               throwsException(new InvalidItemStatus());
            }
         };

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);

         // Nothing left to verify at this point.
      }
   }
</code></pre>
<p>
   As you probably guessed, non-strict expectations differ from strict ones in that they can be
   executed or not by code under test, even if they were not previously recorded. And if they are
   executed, the order of invocations doesn't matter (by default, but it can be made to matter as
   we will see later).
</p>
<p>
   The example tests above show two ways to have non-strict expectations: first, by simply having
   no expectations block at all; second, by specifying expectations inside a
   <code>NonStrictExpectations</code> block.
   In the first case, all invocations to mocked types made in production code will be allowed
   without restrictions, but non-void mocked methods will always return a fixed default value
   according to the method return type. Obviously, this often won't be appropriate, so an
   expectations block of some kind containing recorded invocations will be needed.
   It is also possible to mix strict and non-strict expectations, by using the
   <code>@NonStrict</code> annotation on mocked types, and/or by calling the
   <code>notStrict()</code> method right after an expected invocation while inside an
   <code>Expectations</code> block.
</p>
<p>
   When we use non-strict expectations, invocations to mocked methods and constructors during the
   replay phase are not immediately verified, except that those which were previously recorded do
   produce the designated expected result (either an specific return value or an exception or
   error that gets thrown).
   The fact that an explicitly recorded non-strict expectation allows the test to pass is usually
   enough evidence to demonstrate that the tested unit did the right thing.
   In the second test above for example, if the line that records the <code>items</code> list as the
   expected result from a call to <code>Database.find</code> is commented out,
   the test will fail when another part of the code under test which depends on that returned value
   is verified.
   For constructors and methods of <code>void</code> return type (or even non-void methods whose
   return values were not recorded), invocations can be explicitly verified inside a
   <code>Verifications</code> block which runs <em>after</em> the code under test was exercised.
</p>
<p>
   Syntactically, a <em>verifications code block</em> is just like a expectations code block.
   Invocations to mocked types are immediately verified to match corresponding invocations made
   during the replay phase. Hamcrest matchers can be used so that a single invocation in a
   verifications block verifies several invocations executed by the code under test.
   The invocation count for a particular method or constructor can be verified by specifying
   constraints through one of the <code>repeats</code>, <code>repeatsAtLeast</code>,
   <code>repeatsAtMost</code> methods, just like it can be done for expected invocations in the
   recording phase (ie inside a expectations block).
   Additionally, it can be verified that a particular invocation never happened by calling the
   <code>neverHappens()</code> method just before the invocation to verify is executed inside the
   verifications block.
</p>
<p>
   Next, lets see how the <strong>JMockit Annotations</strong> API solves the problem.
</p>

<pre id="annotations"><code>   package domain;

   import java.math.*;
   import java.util.*;

   import org.junit.*;
   import org.junit.runner.*;
   import static org.junit.Assert.*;
   import mockit.*;
   import static mockit.Mockit.*;
   import mockit.integration.junit4.*;

   import infrastructure.*;

   @RunWith(JMockit.class)
   public final class ServiceA_AnnotationsAPI_Test
   {
      @MockClass(realClass = Database.class)
      public static class MockDatabase
      {
         @Mock(invocations = 1)
(1)      public static List<?> find(String ql, Object arg1)
         {
            assertNotNull(ql);
            assertNotNull(arg1);
            return Collections.EMPTY_LIST;
         }

         @Mock(maxInvocations = 1)
(3)      public static void save(Object o) { assertNotNull(o); }
      }

      @Before
      public void setUp() { setUpMocks(MockDatabase.class); }

      @After
      public void tearDown() { tearDownMocks(); }

      @Test
      public void doBusinessOperationXyz() throws Exception
      {
         final BigDecimal total = new BigDecimal("125.40");

         setUpMock(ServiceB.class, new Object()
         {
            @Mock(invocations = 1)
(2)         public BigDecimal computeTotal(List<?> items)
            {
               assertNotNull(items);
               return total;
            }
         });

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);

         assertEquals(total, data.getTotal());
      }

      @Test(expected = InvalidItemStatus.class)
      public void doBusinessOperationXyzWithInvalidItemStatus() throws Exception
      {
         setUpMock(ServiceB.class, new Object()
         {
            @Mock
(2)         public BigDecimal computeTotal(List<?> items) throws InvalidItemStatus
            {
               throw new InvalidItemStatus();
            }
         });

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);
      }
   }
</code></pre>
<p>
   Here, instead of recording invocations, we directly specify the mock implementations for the
   methods and constructors of interest. Such mocks must have the same signature as the "real"
   methods and constructors, and be annotated with <code>@Mock</code> in a <em>mock class</em>,
   which can be either a separate (nested or not) class annotated with <code>@MockClass</code> or
   an anonymous inner class defined inside a test.
   <br/>
   Constructors in a mock class (not shown above) can also be mocks, but it is usually better to
   use the special method name <code>$init</code> for that. A mock method named <code>$clinit</code>
   will provide a mock implementation for the static initialization block of the real class, if any.
</p>
<p>
   The <code>@Mock</code> annotation can optionally specify exact/min/max
   constraints on the expected number of invocations to the mock method.
   <br/>
   Another attribute of this annotation is <code>reentrant</code> (boolean with default of false),
   which allows a mock method to call back to the real method, causing its real implementation to
   be then executed. For that, an instance field named <code>it</code> must be defined in the mock
   class, and have the same type as the real class. (This is a powerful AOP-like feature which
   should be used sparingly, though.)
</p>

<p>
   Lastly, there is the <strong>JMockit Core</strong> API, which really is just an older and less
   capable version of the Annotations API. It allows tests written with JDK 1.4, but these days
   few developers would actually need that, so it probably will be removed in a future version.
   <br/>
   The following test class uses JUnit 3.8 just for some variation. In reality, JUnit 3.8 and
   JUnit 4.5+ (for Java SE 5+) can always be used. TestNG can also be used (tested with versions
   5.8 and 5.9).
</p>
<pre id="core"><code>   package domain;

   import java.math.*;
   import java.util.*;

   import junit.framework.*;

   import mockit.*;
   import mockit.integration.junit3.*;

   import infrastructure.*;

   public final class ServiceA_CoreAPI_Test extends JMockitTestCase
   {
      private boolean serviceMethodCalled;

      public static class MockDatabase
      {
         static int findMethodCallCount;
         static int saveMethodCallCount;

(1)      public static List<?> find(String ql, Object arg1)
         {
            assertNotNull(ql);
            assertNotNull(arg1);
            findMethodCallCount++;
            return Collections.EMPTY_LIST;
         }

(3)      public static void save(Object o)
         {
            assertNotNull(o);
            saveMethodCallCount++;
         }
      }

      @Override
      protected void setUp() throws Exception
      {
         super.setUp();
         MockDatabase.findMethodCallCount = 0;
         MockDatabase.saveMethodCallCount = 0;
         Mockit.redefineMethods(Database.class, MockDatabase.class);
      }

      @Override
      protected void tearDown() throws Exception
      {
         Mockit.restoreAllOriginalDefinitions();
         super.tearDown();
      }

      public void testDoBusinessOperationXyz() throws Exception
      {
         final BigDecimal total = new BigDecimal("125.40");

         Mockit.redefineMethods(ServiceB.class, new Object()
         {
(2)         public BigDecimal computeTotal(List<?> items)
            {
               assertNotNull(items);
               serviceMethodCalled = true;
               return total;
            }
         });

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);

         assertEquals(total, data.getTotal());
         assertTrue(serviceMethodCalled);
         assertEquals(1, MockDatabase.findMethodCallCount);
         assertEquals(1, MockDatabase.saveMethodCallCount);
      }

      public void testDoBusinessOperationXyzWithInvalidItemStatus()
      {
         Mockit.redefineMethods(ServiceB.class, new Object()
         {
(2)         public BigDecimal computeTotal(List<?> items) throws InvalidItemStatus
            {
               throw new InvalidItemStatus();
            }
         });

         EntityX data = new EntityX(5, "abc", "5453-1");

         try {
            new ServiceA().doBusinessOperationXyz(data);
            fail(InvalidItemStatus.class + " was expected");
         }
         catch (InvalidItemStatus ignore) {
            // OK, test passed
            assertNull(data.getTotal());
            assertEquals(1, MockDatabase.findMethodCallCount);
            assertEquals(0, MockDatabase.saveMethodCallCount);
         }
      }
   }
</code></pre>
<p>
   Notice how these tests emulate the invocation counts of the Annotations API by using static
   fields in the mock class.
</p>
<p>
   Typically, the vast majority of tests can be written with the Expectations API.
   There are situations, however, where the Annotations API can be an useful complement to that.
</p>

<script type="text/javascript" src="../prettify.js"></script>
</body>
</html>
