<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
</head>
<body>
<h2>
   An example
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="RunningTests.html"><img align="right" src="go-next.png" title="Next chapter"></a>
      <a href="Introduction.html"><img align="right" src="go-previous.png" title="Previous chapter"></a>
   </div>
</h2>

<p>
   Say you have a business domain layer class (a "service" class) with a business operation which
   does two things through separate dependencies:
   a) it accesses a database using a simplified API to the persistence subsystem (assume the
   transaction is demarcated at the appropriate point up in the call stack);
   and b) it sends a notification e-mail to the customer through a third-party API (in this example,
   <a href="http://commons.apache.org/email">Commons Email</a> is used).
</p>
<pre><code>import static infrastructure.Database.*;
import org.apache.commons.mail.*;

public final class MyBusinessService
{
   public void doBusinessOperationXyz(EntityX data) throws EmailException
   {
      List&lt;EntityX> items =
(1)      <em>find</em>("select item from EntityX item where item.someProperty = ?1", data.getSomeProperty());

      // Compute or obtain from another service a total value for the new persistent entity:
      BigDecimal total = ...
      data.setTotal(total);

(2)   <em>persist</em>(data);

      sendNotificationEmailToCustomer(data, items);
   }

   private void sendNotificationEmailToCustomer(EntityX data, List&lt;EntityX> items)
      throws EmailException
   {
      Email email = new SimpleEmail();
      email.setSubject("Notification about processing of ...");
      email.addTo(data.getCustomerEmail());

      // Other e-mail parameters, such as the host name of the mail server, have defaults defined
      // through external configuration.

      String message = buildNotificationMessage(items);
      email.setMsg(message);

(3)   email.send();
   }

   private String buildNotificationMessage(List&lt;EntityX> items)
   {
      // Simply builds the message with data from the list of items...
   }
}
</code></pre>
<p>
   The <code>Database</code> class contains only static methods and a private
   constructor; the <code>find</code> and <code>persist</code> methods should be obvious, so we
   won't list them here (assume they are implemented on top of an ORM API, such as Hibernate or
   JPA).
</p>
<p>
   So, how can we unit test the "doBusinessOperationXyz" method without making any changes to the
   existing application code?
   JMockit actually provides four different APIs that can be used, each capable enough for our
   needs.
   (In practice, the first two APIs are just subsets of a larger <em>behavior-oriented</em> mocking
   API, while one of the other two, which can be described as <em>state-oriented</em> mocking APIs,
   is an older and more limited version of the other.)
   We will see how to use each one of them in the following sections.
   In all four cases, a JUnit test case will verify the three invocations of interest made from the
   unit under test to its external dependencies: the method calls at <code>(1)</code>,
   <code>(2)</code>, and <code>(3)</code>.
</p>

<h3 id="expectations">
   Using the Expectations API
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#core"><img align="right" src="go-bottom.png" title="Last section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#verifications"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   First, lets use the <strong>JMockit Expectations</strong> API.
</p>
<pre><code>package domain;

import java.util.*;

import org.apache.commons.mail.*;
import org.junit.*;

import mockit.*;

import infrastructure.*;

public final class MyBusinessService_ExpectationsAPI_Test
{
   @Mocked final Database unused = null;
   @NonStrict SimpleEmail email; // calls to setters are irrelevant, so we make it non-strict

   @Test
   public void doBusinessOperationXyz() throws Exception
   {
      final EntityX data = new EntityX(5, "abc", "5453-1");
      final List&lt;EntityX> items = new ArrayList&lt;EntityX>();
      items.add(new EntityX(1, "AX5", "someone@somewhere.com"));

      new Expectations()
      {
         {
            // "Database" is mocked strictly, therefore the order of these invocations does matter:
(1)         Database.<em>find</em>(withSubstring("select"), (Object[]) null); <em>result</em> = items;
(2)         Database.<em>persist</em>(data);

            // Since "email" is a non-strict mock, this invocation can be replayed in any order:
(3)         email.send(); <em>times</em> = 1; // a non-strict invocation requires a constraint if expected
         }
      };

      new MyBusinessService().doBusinessOperationXyz(data);
   }

   @Test(expected = EmailException.class)
   public void doBusinessOperationXyzWithInvalidEmailAddress() throws Exception
   {
      new NonStrictExpectations()
      {
         {
            email.addTo((String) withNotNull()); <em>result</em> = new EmailException();
         }
      };

      EntityX data = new EntityX(5, "abc", "5453-1");
      new MyBusinessService().doBusinessOperationXyz(data);
   }
}
</code></pre>
<div class="sidebar">
   Other mocking tools usually require a call to some mock creation method, which always returns a
   new object which later needs to be passed to the code under test. In JMockit, such instances may
   be passed to code under test, but don't have to be. In fact, no instance may be used at all, like
   with the <code>final Database unused = null;</code> mock field in the example tests.
</div>
<p>
   First of all, note that <em>what</em> gets mocked is specified through <em>mock fields</em>,
   which in this case are instance fields of the test class annotated as <code>@Mocked</code> and/or
   as <code>@NonStrict</code>.
   A mock field can be of any reference type: an interface, an abstract class, a final/non-final
   class, a class with private constructors only, an enum type, an annotation type, or a generic
   type parameter.
   We say that such a mock field has a <em>mocked type</em>. In truth, it is the type specified to
   be mocked that truly matters; the field itself is not essential, although very useful when the
   test needs a <em>mock object</em> to invoke instance methods on. Such a mock instance will be
   automatically created and assigned to the field, so it will never be left with a
   <code>null</code> reference.
   It is possible to "take over" the value assigned to the mock field, though, by simply declaring
   it as <code>final</code>.
</p>
<p>
   By default, all methods of a class declared as a mocked type will be <em>mocked</em>, that is,
   they will be modified so that the actual method implementation in production code is never
   executed as long as the type stays mocked.
   The same holds true for the constructors of a mocked class.
   Notice that JMockit Expectations does not create any mock subclasses for concrete mocked classes;
   instead, it directly modifies the actual implementation of the mocked class. 
   On the other hand, methods of an interface and abstract methods do not contain any implementation
   to be modified.
   In such cases, an empty implementation body is provided in a concrete implementation class.
   This is all done automatically by JMockit in a transparent way, with no additional effort on the
   part of the developer.
</p>
<p>
   In certain cases, it may be necessary to <em>partially mock</em> a type.
   Specific methods and constructors can be selected to be mocked or not through filter expressions
   provided as an attribute of the <code>@Mocked</code> annotation.
   This annotation has a few other attributes and capabilities which we won't discuss at this point.
   Check the <a href="../javadoc/mockit/Mocked.html">API documentation</a> for the complete
   specification.
</p>
<div class="sidebar">
   JMockit switches automatically from the <em>expectations recording phase</em> to the
   <em>replay phase</em> of the test.
   In EasyMock, a call to <code>replay(mock)</code> is needed for each mock used in the test to make
   this switch.
   In jMock there is also a phase switching method, which takes the form of a call to the
   <code>Mockery#checking(...)</code> method with an instance of an
   <code>org.jmock.Expectations</code> subclass.
</div>
<p>
   As the example tests show, <em>expected/allowed invocations</em> are specified through regular
   method and constructor invocations on mocked types or mock fields, while inside an
   <code>Expectations</code> or <code>NonStrictExpectations</code> block (which is an anonymous
   inner class containing an instance initialization block).
   Each such invocation partly defines an <em>expectation</em> for the test.
   We say that such invocations/expectations are <em>recorded</em> during a <em>record phase</em>,
   so that they can be <em>replayed</em> (and automatically verified) later, during a
   <em>replay phase</em>.
   This second phase of the test starts with the call that exercises the code under test, and lasts
   until the test execution completes.
   This is known as the <em>record-replay model</em> of test execution.
</p>
<p>
   Additional behavior can and often is recorded for an expectation.
   This is done by assigning values to certain fields and/or calling certain methods of the
   Expectations API <em>after</em> the recorded method/constructor invocation of interest, and
   <em>before</em> the next expectation to appear in the block.
   A <em>recorded return value</em> of any type can be assigned to the special
   <strong><code>result</code></strong> field.
   Similarly, a <em>recorded exception</em> (or <em>error</em>) can be recorded by assigning the
   desired <code>Throwable</code> to this same <code>result</code> field.
</p>
<p>
   The method calls <strong><code>withXyz(...)</code></strong>, as well as the field accesses
   <strong><code>anyAbc</code></strong>, allow flexible matching of argument values for the recorded
   invocations.
   Otherwise, an exact match is expected between recorded argument values and the corresponding
   values received in the replay phase.
</p>
<div class="sidebar">
   JMockit automatically verifies all strict expectations before the end of the test, with no extra
   input from the developer.
   In EasyMock it is necessary to explicitly call <code>verify(mock)</code> for each mock used in
   the test.
   jMock also automatically performs an equivalent verification at the end of each test, as long as
   you specify <code>@RunWith(JMock.class)</code> for the test class.
</div>
<p>
   All expectations recorded inside <code>Expectations</code> blocks are <em>strictly verified</em>
   before the end of the test, unless the mocked type was declared as <code>@NonStrict</code>.
   <em>Non-strict</em> invocations (those made to non-strict mocked types or appearing inside a
   <code>NonStrictExpectations</code> block) are only verified if an explicit <em>invocation count
   constraint</em> is specified in the test, through an assignment to the
   <strong><code>times</code></strong> field
   (or alternatively to the <code>minTimes</code> and/or <code>maxTimes</code> fields).
   A <code>java.lang.AssertionError</code> will be thrown for any expected invocation which did not
   happen during the replay phase.
   An error will also be thrown for any invocation to a mocked type that does occur during the
   replay phase, but which was expected to not occur (all the strict ones, by default, but also any
   non-strict ones for which a minimum invocation count was specified and got violated).
   Even more, the test will fail (again, with an <code>AssertionError</code>) if expected
   invocations to one or more strict mocked types are replayed in a different order than they were
   recorded.
</p>
<p>
   There is more to the Expectations API, about which you can find in the chapter on
   <a href="BehaviorBasedTesting.html">behavior-based testing</a>, in the
   <a href="../javadoc/mockit/Expectations.html">API documentation</a>, and also in the many
   additional sample tests inside the full distribution.
</p>

<h3 id="verifications">
   Using the Verifications API
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#core"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#expectations"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#annotations"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Up to this point we focused on <em>strict</em> expectations, that is, those that when recorded
   <em>must</em> be executed by the code under test in the same order.
   Additionally, only explicitly recorded invocations are allowed to execute; any other invocation
   to a mock in the replay phase will be considered <em>unexpected</em>, causing the test to fail.
   Lets now consider testing with <em>non-strict</em> expectations, and the use of the
   <strong>JMockit Verifications</strong> API.
</p>
<pre><code>   package domain;

   import java.util.*;

   import org.junit.*;

   import mockit.*;

   import infrastructure.*;

   public final class ServiceA_VerificationsAPI_Test
   {
      @Mocked final Database onlyStatics = null;
      @Mocked ServiceB serviceB;

      @Test
      public void doBusinessOperationXyzSavesData() throws Exception
      {
         final EntityX data = new EntityX(5, "abc", "5453-1");

         // No expectations recorded in this case.

         new ServiceA().doBusinessOperationXyz(data);

         new Verifications()
         {
(3)         { Database.save(data); }
         };
      }

      @Test
      public void doBusinessOperationXyzFindsItemsAndComputesTotal() throws Exception
      {
         EntityX data = new EntityX(5, "abc", "5453-1");
         final List&lt;?> items = Arrays.asList(1, 2, 3);

         // Invocations that produce a result are recorded, but only those we care about.
         new NonStrictExpectations()
         {
            {
(1)            Database.find(withSubstring("select"), null); returns(items);
            }
         };

         new ServiceA().doBusinessOperationXyz(data);

         new Verifications()
         {
            {
(2)            serviceB.computeTotal(items);
            }
         };
      }

      @Test(expected = InvalidItemStatus.class)
      public void doBusinessOperationXyzWithInvalidItemStatus() throws Exception
      {
         new NonStrictExpectations()
         {
            {
(2)            serviceB.computeTotal((List&lt;?>) withNotNull());
               throwsException(new InvalidItemStatus());
            }
         };

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);

         // Nothing left to verify at this point.
      }
   }
</code></pre>
<p>
   As you probably guessed, non-strict expectations differ from strict ones in that they can be
   executed or not by code under test, even if they were not previously recorded. And if they are
   executed, the order of invocations doesn't matter (by default, but it can be made to matter as
   we will see later).
</p>
<p>
   The example tests above show two ways to have non-strict expectations: first, by simply having
   no expectation block at all; second, by specifying expectations inside a
   <code>NonStrictExpectations</code> block.
   In the first case, all invocations to mocked types made in production code will be allowed
   without restrictions, but non-void mocked methods will always return a fixed default value
   according to the method return type. Obviously, this won't always be appropriate, so an
   expectation block of some kind containing recorded invocations will be needed.
   It is also possible to mix strict and non-strict expectations, by using the
   <code>@NonStrict</code> annotation on mocked types, and/or by calling the
   <code>notStrict()</code> method right after a recorded invocation while inside an
   <code>Expectations</code> block.
</p>
<p>
   When we use non-strict expectations, invocations to mocked methods and constructors during the
   replay phase are not immediately verified (unless explicitly specified otherwise).
   Those non-strict invocations which were recorded with an specific return value or with an
   exception/error to be thrown will produce the expected result if and when replayed by production
   code.
</p>
<p>
   The fact that an explicitly recorded non-strict expectation allows the test to pass is usually
   enough evidence to demonstrate that the tested unit did the right thing.
   In the second test above for example, suppose the line recording <code>items</code> as the
   expected result from a call to <code>Database.find(...)</code> is commented out.
   The test will likely fail when another part of the code under test which depends on that returned
   value is executed, or when an expected invocation is verified in the test itself.
   However, in some cases you may want to be sure that the invocation will occur at least once.
   To achieve that, simply specify it with a regular <code>repeatsAtLeast(1);</code> call after the
   recorded invocation in the non-strict expectation block.
</p>
<div class="sidebar">
   Two other mocking toolkits which provide verification after the replay phase are
   <strong>Mockito</strong> and <strong>Unitils Mock</strong>.
   Besides significant differences in power and API style, they lack JMockit's ability to specify
   invocation count constraints on recorded expectations, thereby forcing developers to explicitly
   verify all expected invocations.
   In addition, JMockit supports both kinds of expectations, not only the non-strict kind supported
   exclusively in Mockito and Unitils.
</div>
<p>
   Another big advantage of non-strict expectations is that they can be <em>explicitly verified</em>
   in test code.
   Such verifications are just like the recording of invocations: simply invoke the method or
   constructor to be verified, but inside a <code>Verifications</code> block.
   Such blocks must always be executed <em>after</em> the code under test was exercised, that is,
   after the end of the replay phase.
   Note that verification blocks will typically contain invocations to constructors and methods of
   <code>void</code> return type.
   Non-void methods can be explicitly verified as well (even if recorded previously in the test),
   although as we saw before they will also be <em>implicitly verified</em> if an invocation count
   constraint was specified in the record phase.
</p>
<p>
   Syntactically, a <em>verification block</em> is just like an expectation block.
   Invocations to mocked types are immediately verified to match corresponding invocations made
   during the replay phase. Hamcrest matchers can be used so that a single invocation in a
   verification block verifies several invocations executed by the code under test.
   The invocation count for a particular method or constructor can be verified by specifying
   constraints through one of the <code>repeats</code>, <code>repeatsAtLeast</code>,
   <code>repeatsAtMost</code> methods, just like it can be done for expected invocations in the
   recording phase.
   In particular, it can be verified that an specific invocation never happened by verifying it with
   a <code>repeats(0);</code> invocation count constraint.
</p>

<h3 id="annotations">
   Using the Annotations API
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#expectations"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#verifications"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#core"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Next, lets see how the <strong>JMockit Annotations</strong> API solves the problem.
</p>
<pre><code>   package domain;

   import java.math.*;
   import java.util.*;

   import org.junit.*;
   import static org.junit.Assert.*;

   import mockit.*;
   import static mockit.Mockit.*;

   import infrastructure.*;

   public final class ServiceA_AnnotationsAPI_Test
   {
      @MockClass(realClass = Database.class)
      public static class MockDatabase
      {
         @Mock(invocations = 1)
(1)      public static List<?> find(String ql, Object arg1)
         {
            assertNotNull(ql);
            assertNotNull(arg1);
            return Collections.emptyList();
         }

         @Mock(maxInvocations = 1)
(3)      public static void save(Object o) { assertNotNull(o); }
      }

      @Before
      public void setUp() { setUpMocks(MockDatabase.class); }

      @After
      public void tearDown() { tearDownMocks(); }

      @Test
      public void doBusinessOperationXyz() throws Exception
      {
         final BigDecimal total = new BigDecimal("125.40");

         setUpMock(ServiceB.class, new Object()
         {
            @Mock(invocations = 1)
(2)         BigDecimal computeTotal(List<?> items)
            {
               assertNotNull(items);
               return total;
            }
         });

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);

         assertEquals(total, data.getTotal());
      }

      @Test(expected = InvalidItemStatus.class)
      public void doBusinessOperationXyzWithInvalidItemStatus() throws Exception
      {
         new MockUp&lt;ServiceB>()
         {
            @Mock
(2)         BigDecimal computeTotal(List<?> items) throws InvalidItemStatus
            {
               throw new InvalidItemStatus();
            }
         };

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);
      }
   }
</code></pre>
<p>
   Here, instead of recording invocations, we directly specify the mock implementations for the
   methods and constructors of interest.
   Such mocks must have the same signature as the "real" methods and constructors, and be annotated
   with <code>@Mock</code> in a <em>mock class</em>, which can be either a separate class (nested or
   not) annotated with <code>@MockClass</code> or an anonymous inner class defined inside a test.
   The last test uses an inline <em>mock-up class</em> instead of using the
   <code>Mockit.setUpMock</code> method. This is in fact the preferred way to define test-specific
   mock classes.
</p>
<p>
   Constructors in a mock class (not shown above) can also be mocks, but it is usually better to
   use the special method name <code>$init</code> for that. A mock method named <code>$clinit</code>
   will provide a mock implementation for the static initialization block of the real class, if any.
</p>
<p>
   The <code>@Mock</code> annotation can optionally specify exact/min/max
   constraints on the expected number of invocations to the mock method.
   <br/>
   Another attribute of this annotation is <code>reentrant</code> (boolean with default of false),
   which allows a mock method to call back to the real method, causing its real implementation to
   be executed. For that, an instance field named <code>it</code> must be defined in the mock
   class, and have the same type as the real class. (This is a powerful AOP-like feature which
   should be used sparingly, though.)
</p>

<h3 id="core">
   Using the Core API
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#expectations"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#annotations"><img align="right" src="go-up.png" title="Previous section"></a>
      <img align="right" src="blank.gif" width="22">
   </div>
</h3>
<p>
   Lastly, there is the <strong>JMockit Core</strong> API, which really is just an older and less
   capable version of the Annotations API. It allows tests written with JDK 1.4, but these days
   few developers would actually need that, so it probably will be removed in a future version.
   <br/>
   The following test class uses JUnit 3.8 just for some variation. In reality, JUnit 3.8 and
   JUnit 4.5+ (for Java SE 5+) can always be used. TestNG 5.8+ can also be used.
</p>
<pre><code>   package domain;

   import java.math.*;
   import java.util.*;

   import junit.framework.*;

   import mockit.*;

   import infrastructure.*;

   public final class ServiceA_CoreAPI_Test extends TestCase
   {
      private boolean serviceMethodCalled;

      public static class MockDatabase
      {
         static int findMethodCallCount;
         static int saveMethodCallCount;

(1)      public static List<?> find(String ql, Object arg1)
         {
            assertNotNull(ql);
            assertNotNull(arg1);
            findMethodCallCount++;
            return Collections.EMPTY_LIST;
         }

(3)      public static void save(Object o)
         {
            assertNotNull(o);
            saveMethodCallCount++;
         }
      }

      @Override
      protected void setUp() throws Exception
      {
         super.setUp();
         MockDatabase.findMethodCallCount = 0;
         MockDatabase.saveMethodCallCount = 0;
         Mockit.redefineMethods(Database.class, MockDatabase.class);
      }

      @Override
      protected void tearDown() throws Exception
      {
         Mockit.restoreAllOriginalDefinitions();
         super.tearDown();
      }

      public void testDoBusinessOperationXyz() throws Exception
      {
         final BigDecimal total = new BigDecimal("125.40");

         Mockit.redefineMethods(ServiceB.class, new Object()
         {
(2)         public BigDecimal computeTotal(List<?> items)
            {
               assertNotNull(items);
               serviceMethodCalled = true;
               return total;
            }
         });

         EntityX data = new EntityX(5, "abc", "5453-1");
         new ServiceA().doBusinessOperationXyz(data);

         assertEquals(total, data.getTotal());
         assertTrue(serviceMethodCalled);
         assertEquals(1, MockDatabase.findMethodCallCount);
         assertEquals(1, MockDatabase.saveMethodCallCount);
      }

      public void testDoBusinessOperationXyzWithInvalidItemStatus()
      {
         Mockit.redefineMethods(ServiceB.class, new Object()
         {
(2)         public BigDecimal computeTotal(List<?> items) throws InvalidItemStatus
            {
               throw new InvalidItemStatus();
            }
         });

         EntityX data = new EntityX(5, "abc", "5453-1");

         try {
            new ServiceA().doBusinessOperationXyz(data);
            fail(InvalidItemStatus.class + " was expected");
         }
         catch (InvalidItemStatus ignore) {
            // OK, test passed
            assertNull(data.getTotal());
            assertEquals(1, MockDatabase.findMethodCallCount);
            assertEquals(0, MockDatabase.saveMethodCallCount);
         }
      }
   }
</code></pre>
<p>
   Notice how these tests emulate the invocation counts of the Annotations API by using static
   fields in the mock class.
</p>
<p>
   Typically, the vast majority of tests can be written with the Expectations API.
   There are situations, however, where the Annotations API can be an useful complement to that.
</p>
<div class="navigation">
   <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
   <a href="RunningTests.html"><img align="right" src="go-next.png" title="Next chapter"></a>
   <a href="Introduction.html"><img align="right" src="go-previous.png" title="Previous chapter"></a>
</div>
<br/>
<script type="text/javascript" src="../prettify.js"></script>
</body>
</html>
