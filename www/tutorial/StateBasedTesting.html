<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
</head>
<body>
<h2>State-based testing with JMockit</h2>

<p>
   In the JMockit toolkit, the <strong>Annotations API</strong> provides support for the creation of
   <em>state-based</em> tests.
   The focus when doing this kind of testing is not on the <em>interactions</em> between objects,
   but on their <em>state</em> after the code under test is exercised, and on the data items
   exchanged between objects.
</p>
<p>
   State verification <em>after</em> the unit under test is exercised is typically done through
   regular JUnit/TestNG assertions written at the end of each test method.
   The Annotations API allows a test to do state verification, with those same JUnit/TestNG
   assertions, <em>during the execution of the tested code</em>.
   As the tested unit passes data to dependencies through method and constructor invocations, the
   corresponding mock implementations specified for those dependencies will get called.
   These implementations (usually defined inside test classes) will then execute the appropriate
   assertions on the received invocation arguments.
   In addition, the API allows the test to verify if any given method or constructor of a mocked
   dependency is called at all, or more generally to verify the actual number of invocations against
   an specified exact, minimum, or maximum number of invocations.
</p>
<div style="text-align: center;" title="Click for API documentation">
   <map name="figure1">
      <area shape="rect" coords="328,15,442,42" href="../javadoc/mockit/MockUp.html">
      <area shape="rect" coords="16,47,100,74" href="../javadoc/mockit/Mockit.html">
      <area shape="rect" coords="113,47,191,74" href="../javadoc/mockit/Mock.html">
      <area shape="rect" coords="203,47,313,74" href="../javadoc/mockit/MockClass.html">
      <area shape="rect" coords="324,47,441,74" href="../javadoc/mockit/Instantiation.html">
   </map>
   <img src="StateBasedAPI.png" usemap="#figure1">
</div>
<p>
   For the remaining of this chapter, lets say we want to write unit tests for an application that
   uses the
   <a href="http://java.sun.com/javase/6/docs/api/javax/security/auth/login/LoginContext.html">
      javax.security.auth.login.LoginContext</a> class (from the standard JAAS API) in order to
   authenticate users.
   In this case, we don't want our tests to actually execute any of the real JAAS code, since it may
   depend on external configuration and might not easily work in a developer testing environment.
   Besides, we also don't want to exercise real JAAS code in a unit test because obviously that is
   not part of the application code we <em>are</em> trying to test.
   (Of course, in <em>integration tests</em> we just might work with a real JAAS setup.)  
   Therefore, an application class depending on <code>LoginContext</code> will be our "unit under
   test", while the <code>LoginContext</code> class (the dependency) will need to have at least some
   of its methods and constructors "mocked" for any given test which involves authentication logic.
</p>

<h3 id="mocks">Mock methods and mock classes</h3>
<p>
   In the context of the JMockit Annotations API, a <em>mock method</em> is one annotated with the
   <code>mockit.Mock</code> annotation.
   The class to which such methods belong is a <em>mock class</em>.
   Similarly, a <em>mock constructor</em> is a constructor of a mock class, when annotated as
   <code>@Mock</code>.
   For short, in this chapter we will refer to such annotated mock methods and constructors simply
   as "mocks" (in other contexts, the word "mock" may refer to an <em>instance</em> of a mocked
   class instead).
   The example below shows several mocks defined in a mock class.
</p>
<pre><code>   public static class MockLoginContext
   {
      MockLoginContext() {}

      @Mock
      public MockLoginContext(String name, CallbackHandler callbackHandler)
      {
         assertEquals("test", name);
         assertNotNull(callbackHandler);
      }

      @Mock
      public void login() {}

      @Mock
      public Subject getSubject() { return null; }
   }
</code></pre>
<p>
   Mock classes are often defined as nested classes inside a JUnit/TestNG test class.
   That's why this example mock class is declared to be <code>static</code>; it could also have been
   an inner (non-static) class.
   There is nothing preventing mock classes from being top-level, though.
   That would be useful if the mock class is to be reused in multiple test classes.
   As we'll see later, though, the most convenient way to implement mock classes is by making them
   <em>anonymous</em> and <em>local</em> to an individual test method.
</p>
<p>
   A new mock class is created (as part of the test code) when we have a "real class" defined in
   production code which needs to be mocked for a given test.
   By convention, for a real class named <code>Abc</code> we create a corresponding mock class named
   <code>MockAbc</code> (when using named mock classes, that is).
   This is just a convention, though. A mock class in fact is completely independent from whichever
   real class it targets. It should define at least one mock method or mock constructor, and may
   have any number of additional methods and constructors; it can also define any number of fields.
</p>
<p>
   For each mock method/constructor, on the other hand, there must exist a "real method/constructor"
   with the <em>same signature</em> (name and parameters in the case of a mock method, or just the
   parameters in the case of a mock constructor) in the targeted real class.
   If the real method/constructor corresponding to a given mock method/constructor is missing from
   the real class, an instance of <code>mockit.RealMethodNotFoundForMockException</code> will be
   thrown when a test attempts to apply the mock class to the corresponding real class (the next
   section discusses how exactly this is done).
   Notice this exception can be caused by a refactoring in the real class (such as renaming the
   real method), so it's important to understand why it happens.
</p>
<p>
   Finally, notice there is no need to have mocks for <em>all</em> methods and constructors in a
   real class.
   Any such method or constructor for which no corresponding mock exists in the mock class will
   simply stay "as is", that is, it won't be mocked.
   This, of course, assuming there isn't some <em>other</em> mock class applied by the same test
   to the same real class, something which is perfectly valid (and sometimes useful).
   If two (or more) mock classes happen to be applied to the same real class for the same test,
   then such mock classes should avoid defining the same mock twice. In case a mock <em>is</em>
   duplicated, though, the "last" one to be applied wins.
</p>
<p>
   When a mock class is applied to a real class, the latter gets the implementation of those methods
   and constructors which have corresponding mocks temporarily replaced/redefined with the
   implementations of the respective mock methods and constructors as defined in the mock class.
   In other words, the real class becomes "mocked" for the duration of the test which applied the
   mock class, and will respond accordingly whenever it receives invocations during test execution.
   At runtime, what really happens is that the execution of a mocked method/constructor is
   intercepted and redirected to the corresponding mock method/constructor, which then executes
   and returns (unless a exception/error is thrown) to the original caller, without this one
   noticing that a different method/constructor was actually executed.
   Normally, the "caller" class is the one under test, while the mocked class is a dependency.
</p>
<p>
   In the example above, we have one mock constructor and two mock methods.
   Since such mocks can be used to verify the "state" passed from the class/unit under test to its
   dependencies, we commonly see JUnit/TestNG assertions in them.
   Such assertions will verify that the input arguments are as expected. When one of them fails,
   the test will fail for the same reason (and with the same <code>AssertionError</code>).
   Obviously, writing these assertions (if any) is up to the developer.
   A mock method for a non-<code>void</code> real method will have to return an appropriate value
   to the caller, based on the requirements of the class under test.
   When an exceptional situation is being tested, a mock method or constructor will typically
   throw an exception or error to simulate that situation.
   Later we will see concrete examples for all of these different test cases.
</p>

<h3 id="setUp">Setting up mocks for a test</h3>
<p>
   A given mock class must be applied to a corresponding real class to have any effect.
   We call this "setting up" the mock class.
   This is normally done for a specific test or set of tests. In the first case, it occurs inside
   individual test methods. In the second one, a <code>@BeforeMethod</code> (TestNG),
   <code>setUp()</code> (JUnit 3.8), or <code>@Before</code> (JUnit 4) method can be used.
   During the time a mock class is in effect, the methods and constructors of the real class which
   have corresponding mocks will stay mocked, with any calls made on them automatically and
   transparently redirected to the corresponding mocks for execution.
   There are several different ways to set up mock classes, each with a different way to specify the
   corresponding real class, as we'll now see.
</p>

<h4>Setting up mocks for a real class chosen at setup time</h4>
<p>
   For the <code>MockLoginContext</code> mock class above, the corresponding real class is
   <code>javax.security.auth.login.LoginContext</code>.
   To set it up for an individual test, we could write the following (assuming the necessary
   imports):
</p>
<pre><code>   @Test
   public void setUpMocksForGivenRealClassWithGivenMockInstance() throws Exception
   {
      <strong>Mockit.setUpMock</strong>(LoginContext.class, <strong>new MockLoginContext()</strong>);

      // Inside an application class which creates a suitable <code>CallbackHandler</code>:
      new LoginContext("test", callbackHandler).login();

      ...
   }
</code></pre>
<p>
   Since the call above to <code>Mockit.setUpMock</code> occurs inside a test method, the mocking
   of <code>LoginContext</code> by <code>MockLoginContext</code> will be in effect only for this
   particular test.
</p>
<p>
   When the constructor invocation that instantiates <code>LoginContext</code> executes, the
   corresponding mock constructor in <code>MockLoginContext</code> will be executed, asserting the
   validity of the invocation arguments.
   Similarly, when the <code>LoginContext#login</code> method is called, the corresponding mock
   method will be executed, which in this case will do nothing since the method has no parameters
   and <code>void</code> return type.
</p>
<p>
   Notice the mock class used here has a no-args constructor which is <em>not</em> a mock, since it
   is not annotated.
   The test uses this constructor to instantiate the mock class, passing this instance in the call
   to <a href="../javadoc/mockit/Mockit.html#setUpMock(java.lang.Class, java.lang.Object)">
      Mockit.setUpMock(Class<?> realClass, Object mock)</a>.
   This mock instance will be the one on which any mock method (such as <code>login</code>) is
   called.
   On the other hand, it won't be the instance on which a mock constructor is invoked; a mock
   constructor will always be called on a newly created instance of the mock class, since
   constructors cannot be called on pre-existing instances.
</p>
<p>
   The (partial) example test above would simply verify that the <code>LoginContext</code> class
   is instantiated with valid arguments when one particular constructor that takes a context name
   and a callback handler is used. If the class is not instantiated at all, the test would still
   pass (unless some other condition causes it to fail).
   The invocation of the <code>login</code> method also has no effect on the outcome of this test,
   except for the fact that such an invocation will result in the execution of an empty mock method
   instead of the real method.
</p>
<p>
   Now, what if we wanted to simulate an authentication failure for a different test?
   The <code>LoginContext#login()</code> method declares that it can throw a
   <code>LoginException</code> "if the authentication fails", so what we need to do is very simple
   (using JUnit 4 in this example):
</p>
<pre><code>   public static class MockLoginContextThatFailsAuthentication
   {
      MockLoginContextThatFailsAuthentication() {}

      @Mock
      public MockLoginContext(String name) {}

      @Mock
      public void login() throws LoginException
      {
         throw new LoginException();
      }
   }

   @Test(expected = LoginException.class)
   public void setUpMocksForGivenRealClassWithoutPrecreatedMockInstance() throws Exception
   {
      Mockit.setUpMock(LoginContext.class, <strong>MockLoginContextThatFailsAuthentication.class</strong>);

      // Inside an application class:
      new LoginContext("test").login();
   }
</code></pre>
<p>
   This test will only pass if the <code>LoginContext#login</code> method throws an exception, which
   it will when the corresponding mock method is executed.
   Notice that in this case we passed the class literal for the mock class instead of an instance.
   This will cause a new instance of the mock class to be created automatically <em>every time</em>
   a non-<code>static</code> mock method needs to be called (which happens whenever a mocked method
   on the real class is called).
   The mock method will be called on this new instance, which will then be discarded
   (that is, it won't be reused later for new invocations).
   Naturally, mock methods that are <code>static</code> are never called on any instance, so no new
   instance is created for them.
</p>

<h4>Which kinds of methods can have mocks?</h4>
<p>
   So far, we have only mocked public instance methods with public instance mock methods.
   In reality, any other kind of method in a real class can be mocked: methods with
   <code>private</code>, <code>protected</code> or "package-private" accessibility,
   <code>static</code> methods, <code>final</code> methods, and <code>native</code> methods.
   (Also <code>synchronized</code> and <code>strictfp</code> methods, but these modifiers only
   affect the method implementation, not its interface.)
   Even more, an <code>static</code> method in the real class can be mocked by an <em>instance</em>
   mock method, and vice-versa (an instance real method with an static mock);
   the same applies for the <code>final</code> modifier.
</p>
<p>
   In a named mock class, mocks usually need to be declared as <code>public</code>, otherwise an
   <code>IllegalAccessError</code> might get thrown.
</p>

<h4>Using the <code>@MockClass</code> annotation</h4>
<p>
   The <code>Mockit.setUpMock</code> method, in all of its two-parameter variations, requires the
   real class to be explicitly provided through an argument.
   The <a href="../javadoc/mockit/Mockit.html#setUpMocks(java.lang.Object...)">Mockit.setUpMocks</a>
   method, in contrast, takes only mock class literals and/or mock class instances.
   The applicable real class is specified through the <code>mockit.MockClass</code> annotation,
   applied on the mock class itself, as the following example shows.
</p>
<pre><code>   @MockClass(realClass = LoginContext.class)
   public static class MockLoginContext
   {
      // @Mocks here...
   }

   @MockClass(realClass = SomethingElse.class)
   public final class MockSomethingElse
   {
      // @Mocks here...
   }

   @Test
   public void setUpMocksForMultipleClasses()
   {
      Mockit.<strong>setUpMocks(MockLoginContext.class, new MockSomethingElse())</strong>;

      // Calls code under test that uses the "LoginContext" and "SomethingElse" classes:
      ...
   }
</code></pre>
<p>
   The <code>realClass</code> attribute is mandatory for <code>@MockClass</code>.
   A mock class is normally used for the same real class every time. Therefore, nothing more natural
   than associating said class directly with the mock class, avoiding the need to specify it every
   time the mocks are set up.
</p>

<h4>In-line mock classes</h4>
<p>
   Named mock classes, typically defined as nested or inner classes of the test class, definitely
   have their place.
   Often, however, an specific group of mocks for a given real class will be useful for a single
   test.
   In such a situation we can create <em>anonymous mock classes</em> inside individual test methods,
   as demonstrated by the next example.
</p>
<pre><code>   @Test
   public void setUpMocksUsingAnonymousMockClass() throws Exception
   {
      Mockit.setUpMock(LoginContext.class, new Object()
      {
         @Mock
         void $init(String name) { assertEquals("test", name); }

         @Mock
         void login() {}
      });

      new LoginContext("test").login();
   }
</code></pre>
<p>
   An anonymous mock class is always instantiated at the place of definition and cannot be annotated
   with <code>@MockClass</code>, so we need a mock setup mechanism that takes both the real class
   and the mock instance.
   In addition to that, an anonymous class cannot define its own constructors (apart from the
   implicit constructor that initializes the local instance), so we can't have mock constructors.
   As the example above shows, though, we can mock any constructor of the real class by defining a
   mock method with the special name <code>$init</code>, return type <code>void</code>, and the same
   parameters as the desired constructor in the real class.
</p>
<p>
   A more elegant alternative to the use of <code>Mockit.setUpMock</code> with an "in-line mock
   class" is shown next, using the <code>mockit.MockUp&lt;T></code> generic base class.
</p>
<pre><code>   @Test
   public void setUpMocksUsingLocalMockUpClass() throws Exception
   {
      new MockUp&lt;LoginContext>()
      {
         @Mock
         void $init(String name) { assertEquals("test", name); }

         @Mock
         void login() {}
      };

      new LoginContext("test").login();
   }
</code></pre>
<p>
   In this case, we still have an anonymous mock class, but it is created as a subclass of
   <strong><code>MockUp&lt;T></code></strong> where the real class is specified through the generic
   <em>type parameter</em> <strong><code>T</code></strong>.
   (Subclasses of <code>MockUp</code> can also be named, of course.)
   Given this succinct and readable syntax, and the fact that mock classes tend to be specific to
   individual tests, the creation of such <em>mock-up classes</em> should be the most common way to
   define mocks with the Annotations API.
</p>
<p>
   As the previous example tests have shown, it is perfectly safe to declare mock methods in an
   anonymous mock class as non-<code>public</code> (always).
   This is an added bonus over annotated (and named) mock classes, which often (but not always) need
   to be public with their mocks also public.
</p>

<h3>Mocking interfaces</h3>
<p>
   Most of the time a mock class targets a real class directly.
   But what if we need a mock object that implements a certain interface, to be passed to code under
   test?
   The two following example tests show how it is done, one using an annotated mock class, the other
   a mock-up class. The mocked interface is
   <a href="http://java.sun.com/javase/6/docs/api/javax/security/auth/callback/CallbackHandler.html">
      javax.security.auth.callback.CallbackHandler</a>.
</p>
<pre><code>   @Test
   public void setUpMocksForInterface() throws Exception
   {
      CallbackHandler callbackHandler = Mockit.setUpMock(new MockCallbackHandler());

      callbackHandler.handle(new Callback[] {new NameCallback("Enter name:")});
   }

   @MockClass(realClass = CallbackHandler.class)
   public static class MockCallbackHandler
   {
      @Mock
      public void handle(Callback[] callbacks)
      {
         assertEquals(1, callbacks.length);
         assertTrue(callbacks[0] instanceof NameCallback);
      }
   }

   @Test
   public void mockInterfaceWithMockUp() throws Exception
   {
      CallbackHandler callbackHandler = new MockUp&lt;CallbackHandler>()
      {
         @Mock
         void handle(Callback[] callbacks)
         {
            assertEquals(1, callbacks.length);
            assertTrue(callbacks[0] instanceof NameCallback);
         }
      }.getMockInstance();

      callbackHandler.handle(new Callback[] {new NameCallback("Enter name:")});
   }
</code></pre>
<p>
   The
   <a href="../javadoc/mockit/Mockit.html#setUpMock(java.lang.Object)">Mockit.setUpMock(Object)</a>
   method returns a proxy object that implements the desired interface.
   The object passed to this method must be an instance of an annotated mock class which specifies
   the interface as the value for the <code>realClass</code> attribute.
   Again, a more elegant alternative is obtained with the use of a mock-up class, which provides
   the proxy instance through a call to the <code>getMockInstance()</code> method.
   (This method returns <code>null</code> when the mocked type is not an interface, though.)
</p>
<p>
   Notice that for the first test the mock class and its mock methods are declared to be
   <code>public</code> and must be so to avoid an <code>IllegalAccessError</code>, while in the
   second test the mock-up class and the mock method <em>don't have</em> to be public (an anonymous
   class is always non-public anyway).
</p>

<h3>Specifying stubs with a mock class</h3>
<p>
   The <code>@MockClass</code> annotation also gives us the ability to specify methods and/or
   constructors in the real class that should be <em>stubbed out</em> so they have no effect when
   called during a test.
   Stubbing out a method achieves the same result as mocking it with a mock method that does
   nothing, except for returning the default value according to the method return type when it's
   not <code>void</code>.
</p>
<p>
   The following example tests make use of this feature.
</p>
<pre><code>   @Test
   public void mockAndStubOutClassAccordingToSpecifiedStubs() throws Exception
   {
      Mockit.setUpMocks(new MockLoginContextWithStubs());

      LoginContext context = new LoginContext("");
      context.login();
      context.logout();
   }

   @MockClass(realClass = LoginContext.class, stubs = {"(String)", "logout"})
   final class MockLoginContextWithStubs
   {
      @Mock
      void login() {} // this could also have been an stub
   }

   @Test
   public void mockAndStubOutClassAccordingToSpecifiedInverseStubs() throws Exception
   {
      Mockit.setUpMocks(MockLoginContextWithInverseStubs.class);

      LoginContext context = new LoginContext("", null, null);
      context.login();
      context.logout();
   }

   @MockClass(realClass = LoginContext.class, stubs = "", inverse = true)
   static class MockLoginContextWithInverseStubs
   {
      @Mock
      static void login() {}
   }
</code></pre>
<p>
   In the first test above, the constructor of the real class (<code>LoginContext</code>) which has
   one parameter of type <code>String</code> is stubbed out, as well as all methods in the same
   class with name <code>logout</code>. Parameters are ignored if not specified in the stub filter,
   so all overloads (in case there is more than one) with the same method name will be stubbed out.
</p>
<p>
   The second mock class, <code>MockLoginContextWithInverseStubs</code>, uses the
   <code>inverse</code> attribute (which by default is <code>false</code>) to specify that all
   methods and constructors <em>not</em> matching the specified stub filters will be stubbed out.
   In this example, the list of stub filters contains only an empty filter which matches nothing,
   so everything in the real class is stubbed out. Any mocks defined in the mock class will override
   the stub, however.
</p>
<p>
   Each stub filter string specified with the <code>stubs</code> attribute can match any number of
   methods of the real class, since the initial part actually is a <em>regular expression</em> for
   method names.
   For constructors, this part is left empty since they have no names.
   The second part in a stub filter string, which can be empty for methods but never for
   constructors, is a comma-separated list of parameter type names, between parentheses.
   Each parameter type name either is the name of a primitive type, or a fully qualified reference
   type name.
   For convenience, it can be a <em>unique suffix</em> for such type names instead; this makes it
   easy to specify reference type names, since in most cases the package name can be omitted.
   Finally, as seen in the example above, the empty stub filter will match <em>no</em> methods or
   constructors in the real class, or <em>all</em> methods and constructors if used with
   <code>inverse = true</code>.
</p>

<h3 id="constraints">Invocation count constraints</h3>
<p>
   All example tests shown so far only used JUnit/TestNG "asserts" to verify invocation arguments.
   This is the part of the API that extends conventional state-based testing to the data items
   exchanged between objects.
   Sometimes, though, we may want to verify if a given method/constructor in a dependency is invoked
   at all by the unit under test.
   We may also want to verify exactly how many invocations a given mock received during the
   execution of a test, or specify that the test should fail if more/less than a certain number of
   invocations occurs.
   For this, we can specify <em>declarative constraints</em> on the <em>invocation count</em> of a
   given mock, as the following example shows.
</p>
<pre><code>   @Test
   public void specifyInvocationCountConstraints() throws Exception
   {
      Mockit.setUpMock(LoginContext.class, new Object()
      {
         @Mock(minInvocations = 1)
         void $init(String name) { assertEquals("test", name); }

         @Mock(invocations = 1)
         void login() {}

         @Mock(maxInvocations = 1)
         void logout() {}
      });

      new LoginContext("test").login();
   }
</code></pre>
<p>
   (In the test above we used an anonymous mock class with the <code>setUpMock</code> method,
   although a nicer solution could be obtained with a local <code>MockUp</code> object.)
   In this test we used all three attributes of the <code>@Mock</code> annotation related to
   invocation counts.
   The first mock specifies that the <code>LoginContext(String)</code> constructor must be invoked
   <em>at least once</em> during the test.
   The second one specifies that the <code>login()</code> method must be invoked <em>exactly
   once</em>, while the third declares that <code>logout()</code> <em>can</em> be invoked, but not
   more than once.
</p>
<p>
   It is also valid to specify both <code>minInvocations</code> and <code>maxInvocations</code> on
   the same mock, in order to constrain the invocation count to a given range.
</p>

<h3>Mocking and stubbing class initializers</h3>
<p>
   When a class in production code performs some work in one or more <em>static initialization
   blocks</em>, we often need to stub it out so it doesn't interfere with test execution.
   To do just that for a given real class, we can write something like
   <code>@MockClass(realClass = MyRealClass.class, <strong>stubs = "&lt;clinit>"</strong>)</code>.
   If we instead want some test code to execute when the static initialization of the real class
   gets executed by the JVM, then we can define an special mock, as shown below.
</p>
<pre><code>   @Test
   public void mockStaticInitializer()
   {
      new MockUp&lt;ClassWithStaticInitializers>()
      {
         @Mock(invocations = 1)
         void $clinit()
         {
            // Do something here.
         }
      };

      ClassWithStaticInitializers.doSomething();
   }
</code></pre>
<p>
   We can even verify that static initialization occurs, as specified by the invocation count
   constraint above. Notice however that once loaded by the JVM, a class will be initialized no more
   than once, so the test would fail if it runs after the class has already been initialized.
</p>

<h3 id="instantiation">Controlling the instantiation of mock classes</h3>
<p>
   We have already seen three different situations when mock classes get instantiated:
</p>
<ol>
   <li>
      The mock class is instantiated directly by test code with the <code>new</code> operator, and
      passed to JMockit in a call to a <code>Mockit.setUpMock</code> or
      <code>Mockit.setUpMocks</code> method, or alternatively as a <code>MockUp</code> subclass
      instance.
      In this case the same mock instance is used for all calls to instance mock methods, as long as
      the mock class remains in effect.
   </li>
   <li>
      The mock class is instantiated "behind the covers" by JMockit whenever it needs an instance to
      invoke an instance mock method on.
      In this situation a mock instance is created, a mock is executed on it, and then it is
      discarded (that is, it becomes eligible for garbage collection).
   </li>
   <li>
      JMockit instantiates the mock class so that a mock constructor can be invoked, whenever the
      corresponding mocked constructor is invoked by tested code.
      This situation cannot be avoided for mock constructors, since pre-existing instances can't be
      used.
   </li>
</ol>
<p>
   Sometimes it may be important to have more control on when exactly a mock class is automatically
   instantiated by JMockit (except for the third situation above, which cannot be changed but can be
   avoided by using a <code>$init</code> mock method instead of a mock constructor).
   There is also a situation which is not covered by the previously described instantiation
   mechanisms, and which may be needed or useful for certain test cases: <em>instantiation per
   mocked instance</em>.
   To cover such needs the <code>@MockClass</code> annotation has an <code>instantiation</code>
   attribute, whose values are given by the
   <a href="../javadoc/mockit/Instantiation.html">Instantiation</a> "enum".
   The default value for this attribute is <code>Instantiation.PerMockInvocation</code>.
</p>
<p>
   The following sub-sections describe each of the possible instantiation modes which can be used
   to control how and when JMockit creates automatic mock class instances.
   Notice this is applicable only to situation 2 above.
</p>

<h4>Instantiation per Mock Setup</h4>
<p>
   For a mock class annotated as
   <code>@MockClass(realClass = ..., <strong>instantiation = PerMockSetup</strong>)</code>, a call
   like <code>Mockit.setUpMock(realClass, MyMockClass.class)</code> or
   <code>Mockit.setUpMocks(MyMockClass.class)</code> will result in the creation of the mock
   instance at the time of the call.
   This single mock instance will then be used for all instance method invocations, for as long as
   the mock class remains in effect.
</p>
<p>
   Notice this is equivalent to passing an instance created by test code in one of those mock setup
   calls.
</p>

<h4>Instantiation per Mock Invocation</h4>
<p>
   For a mock class annotated as
   <code>@MockClass(realClass = ..., <strong>instantiation = PerMockInvocation</strong>)</code>, a
   call like <code>Mockit.setUpMock(realClass, MyMockClass.class)</code> or
   <code>Mockit.setUpMocks(MyMockClass.class)</code> will <em>not</em> result in the creation of any
   mock instance at this time, but will later if and when an instance mock method needs to be
   invoked.
   For each such invocation, a new mock instance is created and then discarded as soon as the mock
   call terminates.
</p>
<p>
   Notice this is the default JMockit behavior when a class literal for the mock class is passed in
   a mock setup call, and the <code>instantiation</code> attribute isn't specified.
</p>

<h4>Instantiation per Mocked Instance</h4>
<p>
   For a mock class annotated as
   <code>@MockClass(realClass = ..., <strong>instantiation = PerMockedInstance</strong>)</code>, a
   call like <code>Mockit.setUpMock(realClass, MyMockClass.class)</code> or
   <code>Mockit.setUpMocks(MyMockClass.class)</code> will result in the <em>on-demand</em> creation
   of one new mock instance for each and every new <em>mocked instance</em>.
   In other words, once the mock class is in effect, whenever a mocked instance method of the real
   class is invoked, a paired instance of the mock class will be created if none yet exists for that
   particular instance of the real class; this same mock instance will then be used for all
   invocations to mock instance methods.
</p>
<p>
   The ability to have a mock class instance for each real class instance will normally only be
   useful if the mock class stores some state that is specific to each instance of the real class.
</p>
<p>
   Notice the mock object lifetime described above can only be achieved by using this particular
   instantiation mode.
</p>

<h3 id="it">Accessing the mocked object: the "it" field</h3>
<p>

</p>

<h3 id="reentrant">Reentrant mocks</h3>
<p>

</p>

<h3>Reusing mocks between tests</h3>

<script type="text/javascript" src="../prettify.js"></script>
</body>
</html>
