<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
   <script type="text/javascript" src="../highlight.pack.js"></script>
   <script type="text/javascript">hljs.initHighlightingOnLoad()</script>
</head>
<body>
<h2>
   State-based testing with JMockit
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="ReflectionUtilities.html"><img align="right" src="go-next.png" title="Next chapter"></a>
      <a href="BehaviorBasedTesting.html"><img align="right" src="go-previous.png" title="Previous chapter"></a>
   </div>
</h2>

<ol style="border: medium ridge; background-color: beige;">
   <li><a href="#mocks">Mock methods and mock classes</a></li>
   <li>
      <a href="#setUp">Setting up mocks for a test</a>
      <ol>
         <li><a href="#setupTime">Setting up mocks for a real class chosen at setup time</a></li>
         <li><a href="#mockableMethods">Which kinds of methods can have mocks?</a></li>
         <li><a href="#MockClass">Using the <code>@MockClass</code> annotation</a></li>
         <li><a href="#inline">In-line mock classes</a></li>
      </ol>
   </li>
   <li><a href="#interfaces">Mocking interfaces</a></li>
   <li><a href="#stubs">Specifying stubs with a mock class</a></li>
   <li><a href="#constraints">Invocation count constraints</a></li>
   <li><a href="#initializers">Mocking and stubbing class initializers</a></li>
   <li>
      <a href="#instantiation">Controlling the instantiation of mock classes</a>
      <ol>
         <li><a href="#PerMockSetup">Instantiation per Mock Setup</a></li>
         <li><a href="#PerMockInvocation">Instantiation per Mock Invocation</a></li>
         <li><a href="#PerMockedInstance">Instantiation per Mocked Instance</a></li>
      </ol>
   </li>
   <li><a href="#it">Accessing the mocked object: the "it" field</a></li>
   <li><a href="#reentrant">Reentrant mocks</a></li>
   <li>
      <a href="#reuse">Reusing mocks between tests</a>
      <ol>
         <li><a href="#beforeAfter">Using before/after methods</a></li>
         <li><a href="#reusableMocks">Reusable mock classes</a></li>
      </ol>
   </li>
</ol>

<p>
   In the JMockit toolkit, the <strong>Annotations API</strong> provides support for the creation of
   <em>state-based</em> tests.
   The focus when doing this kind of testing is not on the <em>interactions</em> between objects, but on their
   <em>state</em> after the code under test is exercised, and on the data items exchanged between objects.
</p>
<div style="text-align: center;">
   <map name="figure1">
      <area shape="rect" coords="1,1,86,34" href="../javadoc/mockit/Mockit.html">
      <area shape="rect" coords="93,1,223,34" href="../javadoc/mockit/MockUp.html">
      <area shape="rect" coords="232,1,307,34" href="../javadoc/mockit/Mock.html">
      <area shape="rect" coords="315,1,430,34" href="../javadoc/mockit/MockClass.html">
      <area shape="rect" coords="439,1,574,34" href="../javadoc/mockit/Instantiation.html">
   </map>
   <img src="StateBasedAPI.png" usemap="#figure1">
</div>
<p>
   Regular state verification, performed <em>after</em> exercising the unit under test, is typically done through
   JUnit/TestNG assertions written at the end of each test method.
   The Annotations API extends the ability of a test to do state verification, by allowing those same JUnit/TestNG
   assertions to be executed whenever a dependency is invoked from the tested code.
   As the tested unit passes data to dependencies through method and constructor invocations, the corresponding mock
   implementations specified for those dependencies get called.
   These implementations (usually defined inside test classes) will then execute the appropriate assertions on the
   received invocation arguments.
   In addition, the API allows the test to verify if any given method or constructor of a mocked dependency is called at
   all, or more generally to verify the actual number of invocations against an specified exact, minimum, or maximum
   number of invocations.
</p>
<p>
   For the remaining of this chapter, lets say we want to write unit tests for an application that uses the
   <a href="http://download.oracle.com/javase/6/docs/api/javax/security/auth/login/LoginContext.html">
      javax.security.auth.login.LoginContext</a> class (from the standard JAAS API) in order to authenticate users.
   In this case, we don't want our tests to actually execute any of the real JAAS code, since it may
   depend on external configuration and might not easily work in a developer testing environment.
   Besides, we also don't want to exercise real JAAS code in a unit test because obviously that is
   not part of the application code we <em>are</em> trying to test.
   (Of course, in <em>integration tests</em> we just might work with a real JAAS setup.)  
   Therefore, an application class depending on <code class="type">LoginContext</code> will be our "unit under test",
   while the <code class="type">LoginContext</code> class (the dependency) will need to have at least some of its
   methods and constructors "mocked" for any given test which involves authentication logic.
</p>

<h3 id="mocks">
   Mock methods and mock classes
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#setUp"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   In the context of the JMockit Annotations API, a <em>mock method</em> is one annotated with the
   <code class="type">mockit.Mock</code> annotation.
   The class to which such methods belong is a <em>mock class</em>.
   For short, in this chapter we will refer to such annotated mock methods simply as "mocks" (in other contexts, the
   word "mock" may refer to an <em>instance</em> of a mocked class instead).
   The example below shows several mocks defined in a mock class.
</p>
<pre><code>   public static class MockLoginContext
   {
      @Mock
      public void $init(String name, CallbackHandler callbackHandler)
      {
         assertEquals("test", name);
         assertNotNull(callbackHandler);
      }

      @Mock
      public void login() {}

      @Mock
      public Subject getSubject() { return null; }
   }
</code></pre>
<p>
   Mock classes are often defined as nested classes inside a JUnit/TestNG test class.
   That's why this example mock class is declared to be <code>static</code>; it could also have been
   an inner (non-static) class.
   There is nothing preventing mock classes from being top-level, though.
   That would be useful if the mock class is to be reused in multiple test classes.
   As we'll see later, though, the most convenient way to implement mock classes is by making them
   <em>anonymous</em> and <em>local</em> to an individual test method.
</p>
<p>
   A new mock class is created (as part of the test code) when we have a "real class" defined in
   production code which needs to be mocked for a given test.
   By convention, for a real class named <code class="type">Abc</code> we create a corresponding mock class named
   <code class="type">MockAbc</code> (when using named mock classes, that is).
   This is just a convention, though. A mock class in fact is completely independent from whichever real class it
   targets. It should define at least one mock method, and may have any number of additional methods and constructors;
   it can also define any number of fields.
</p>
<p>
   For each mock method, on the other hand, there must exist a "real method/constructor" with the
   <em>same signature</em> in the targeted real class. For a mocked <em>method</em>, the signature consists of the
   method name and parameters; for a mocked <em>constructor</em>, it's just the parameters, with the mock method having
   the special name "<code>$init</code>".
   If the real method/constructor corresponding to a given mock method is missing from the real class, an
   <code class="type">IllegalArgumentException</code> will be thrown when a test attempts to apply the mock class to the
   corresponding real class (the next section discusses how exactly this is done).
   Notice this exception can be caused by a refactoring in the real class (such as renaming the real method), so it's
   important to understand why it happens.
</p>
<p>
   Finally, notice there is no need to have mocks for <em>all</em> methods and constructors in a real class.
   Any such method or constructor for which no corresponding mock exists in the mock class will simply stay "as is",
   that is, it won't be mocked.
   This, of course, assuming there isn't some <em>other</em> mock class applied by the same test to the same real class,
   something which is perfectly valid (and sometimes useful).
   If two (or more) mock classes happen to be applied to the same real class for the same test, then such mock classes
   should avoid defining the same mock twice.
   In case a mock <em>is</em> duplicated, though, the "last" one to be applied wins.
</p>
<p>
   When a mock class is applied to a real class, the latter gets the implementation of those methods and constructors
   which have corresponding mocks temporarily replaced/redefined with the implementations of the matching mock methods,
   as defined in the mock class.
   In other words, the real class becomes "mocked" for the duration of the test which applied the mock class, and will
   respond accordingly whenever it receives invocations during test execution.
   At runtime, what really happens is that the execution of a mocked method/constructor is intercepted and redirected to
   the corresponding mock method, which then executes and returns (unless an exception/error is thrown) to the original
   caller, without this one noticing that a different method was actually executed.
   Normally, the "caller" class is the one under test, while the mocked class is a dependency.
</p>
<p>
   In the example above, we have three mock methods, with one of them (named "<code>$init</code>") targeting a
   constructor.
   Since such mocks can be used to verify the "state" passed from the class/unit under test to its dependencies, we
   commonly see JUnit/TestNG assertions in them.
   Such assertions will verify that the input arguments are as expected. When one of them fails, the test will fail for
   the same reason (and with the same <code class="type">AssertionError</code>).
   Obviously, writing these assertions (if any) is up to the developer.
   A mock method for a non-<code>void</code> real method will have to return an appropriate value to the caller, based
   on the requirements of the class under test.
   When an exceptional situation is being tested, a mock method will typically throw an exception or error to simulate
   that situation.
   Later we will see concrete examples for all of these different test cases.
</p>

<h3 id="setUp">
   Setting up mocks for a test
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#mocks"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#interfaces"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   A given mock class must be applied to a corresponding real class to have any effect.
   We call this "setting up" the mock class.
   This is normally done for a specific test or set of tests. In the first case, it occurs inside
   individual test methods. In the second one, a <code class="annotation">@BeforeMethod</code> (TestNG),
   <code>setUp()</code> (JUnit 3.8), or <code class="annotation">@Before</code> (JUnit 4) method can be used.
   During the time a mock class is in effect, the methods and constructors of the real class which
   have corresponding mocks will stay mocked, with any calls made on them automatically and
   transparently redirected to the corresponding mocks for execution.
   There are several different ways to set up mock classes, each with a different way to specify the
   corresponding real class, as we'll now see.
</p>

<h4 id="setupTime">Setting up mocks for a real class chosen at setup time</h4>
<p>
   For the <code class="type">MockLoginContext</code> mock class above, the corresponding real class is
   <code class="type">javax.security.auth.login.LoginContext</code>.
   To set it up for an individual test, we could write the following (assuming the necessary imports):
</p>
<pre><code>   @Test
   public void setUpMocksForGivenRealClassWithGivenMockInstance() throws Exception
   {
      <strong>Mockit.setUpMock</strong>(LoginContext.class, <strong>new MockLoginContext()</strong>);

      // Inside an application class which creates a suitable <span class="type">CallbackHandler</span>:
      new LoginContext("test", callbackHandler).login();

      ...
   }
</code></pre>
<p>
   Since the call above to <code>Mockit.setUpMock</code> occurs inside a test method, the mocking of
   <code class="type">LoginContext</code> by <code class="type">MockLoginContext</code> will be in effect only for this
   particular test.
</p>
<p>
   When the constructor invocation that instantiates <code class="type">LoginContext</code> executes, the corresponding
   "<code>$init</code>" mock method in <code class="type">MockLoginContext</code> will be executed, asserting the
   validity of the invocation arguments.
   Similarly, when the <code>LoginContext#login</code> method is called, the corresponding mock method will be executed,
   which in this case will do nothing since the method has no parameters and <code>void</code> return type.
</p>
<p>
   Notice the test instantiates the mock class and passes this instance in the call to
   <a href="../javadoc/mockit/Mockit.html#setUpMock(java.lang.Class, java.lang.Object)">
      <code>Mockit.setUpMock(Class<?> realClass, Object mock)</code></a>.
   This mock instance will be the one on which any mock method (such as <code>login</code>) is called.
</p>
<p>
   The (partial) example test above would simply verify that the <code class="type">LoginContext</code> class is
   instantiated with valid arguments when one particular constructor that takes a context name and a callback handler is
   used.
   If the class is not instantiated at all, the test would still pass (unless some other condition causes it to fail).
   The invocation of the <code>login</code> method also has no effect on the outcome of this test, except for the fact
   that such an invocation will result in the execution of an empty mock method instead of the real method.
</p>
<p>
   Now, what if we wanted to simulate an authentication failure for a different test?
   The <code>LoginContext#login()</code> method declares that it can throw a <code class="type">LoginException</code>
   "if the authentication fails", so what we need to do is very simple (using JUnit 4 in this example):
</p>
<pre><code>   public static class MockLoginContextThatFailsAuthentication
   {
      @Mock
      public void $init(String name) {}

      @Mock
      public void login() throws LoginException
      {
         throw new LoginException();
      }
   }

   @Test(expected = LoginException.class)
   public void setUpMocksForGivenRealClassWithoutPrecreatedMockInstance() throws Exception
   {
      Mockit.setUpMock(LoginContext.class, <strong>MockLoginContextThatFailsAuthentication.class</strong>);

      // Inside an application class:
      new LoginContext("test").login();
   }
</code></pre>
<p>
   This test will only pass if the <code>LoginContext#login</code> method throws an exception, which
   it will when the corresponding mock method is executed.
   Notice that in this case we passed the class literal for the mock class instead of an instance.
   This will cause a new instance of the mock class to be created automatically <em>every time</em>
   a non-<code>static</code> mock method needs to be called (which happens whenever a mocked method
   on the real class is called).
   The mock method will be called on this new instance, which will then be discarded
   (that is, it won't be reused later for new invocations).
   Naturally, mock methods that are <code>static</code> are never called on any instance, so no new
   instance is created for them.
</p>

<h4 id="mockableMethods">Which kinds of methods can have mocks?</h4>
<p>
   So far, we have only mocked public instance methods with public instance mock methods.
   In reality, any other kind of method in a real class can be mocked: methods with
   <code>private</code>, <code>protected</code> or "package-private" accessibility,
   <code>static</code> methods, <code>final</code> methods, and <code>native</code> methods.
   (Also <code>synchronized</code> and <code>strictfp</code> methods, but these modifiers only
   affect the method implementation, not its interface.)
   Even more, an <code>static</code> method in the real class can be mocked by an <em>instance</em> mock method, and
   vice-versa (an instance real method with an static mock); the same applies for the <code>final</code> modifier.
</p>
<p>
   In a named mock class, mocks usually need to be declared as <code>public</code>, otherwise an
   <code class="type">IllegalAccessError</code> might get thrown.
</p>

<h4 id="MockClass">Using the <code class="annotation">@MockClass</code> annotation</h4>
<p>
   The <code>Mockit.setUpMock</code> method, in all of its two-parameter variations, requires the real class to be
   explicitly provided through an argument.
   The <a href="../javadoc/mockit/Mockit.html#setUpMocks(java.lang.Object...)"><code>Mockit.setUpMocks</code></a>
   method, in contrast, takes only mock class literals and/or mock class instances.
   The applicable real class is specified through the <code class="type">mockit.MockClass</code> annotation,
   applied on the mock class itself, as the following example shows.
</p>
<pre><code>   @MockClass(realClass = LoginContext.class)
   public static class MockLoginContext
   {
      // @Mocks here...
   }

   @MockClass(realClass = SomethingElse.class)
   public final class MockSomethingElse
   {
      // @Mocks here...
   }

   @Test
   public void setUpMocksForMultipleClasses()
   {
      Mockit.<strong>setUpMocks(MockLoginContext.class, new MockSomethingElse())</strong>;

      // Calls code under test that uses the "LoginContext" and "SomethingElse" classes:
      ...
   }
</code></pre>
<p>
   The <code>realClass</code> attribute is mandatory for <code class="annotation">@MockClass</code>.
   A mock class is normally used for the same real class every time. Therefore, nothing more natural
   than associating said class directly with the mock class, avoiding the need to specify it every
   time the mocks are set up.
</p>

<h4 id="inline">In-line mock classes</h4>
<p>
   Named mock classes, typically defined as nested or inner classes of the test class, definitely have their place.
   Often, however, an specific group of mocks for a given real class will be useful for a single test.
   In such a situation we can create <em>anonymous mock classes</em> inside individual test methods,
   as demonstrated by the next example.
</p>
<pre><code>   @Test
   public void setUpMocksUsingAnonymousMockClass() throws Exception
   {
      Mockit.setUpMock(LoginContext.class, new Object()
      {
         @Mock
         void $init(String name) { assertEquals("test", name); }

         @Mock
         void login() {}
      });

      new LoginContext("test").login();
   }
</code></pre>
<p>
   An anonymous mock class is always instantiated at the place of definition and cannot be annotated with
   <code class="annotation">@MockClass</code>, so we need a mock setup mechanism that takes both the real class and the
   mock instance.
</p>
<p>
   A more elegant alternative to the use of <code>Mockit.setUpMock</code> with an "in-line mock class" is shown next,
   using the <code class="type">mockit.MockUp&lt;T></code> generic base class.
</p>
<pre><code>   @Test
   public void setUpMocksUsingLocalMockUpClass() throws Exception
   {
      new MockUp&lt;LoginContext>()
      {
         @Mock
         void $init(String name) { assertEquals("test", name); }

         @Mock
         void login() {}
      };

      new LoginContext("test").login();
   }
</code></pre>
<p>
   In this case, we still have an anonymous mock class, but it is created as a subclass of
   <strong><code class="type">MockUp&lt;T></code></strong> where the real class is specified through the generic
   <em>type parameter</em> <strong><code>T</code></strong>.
   (Subclasses of <code class="type">MockUp</code> can also be named, of course.)
   Given this succinct and readable syntax, and the fact that mock classes tend to be specific to individual tests, the
   creation of such <em>mock-up classes</em> should be the most common way to define mocks with the Annotations API.
</p>
<p>
   As the previous example tests have shown, it is perfectly safe to declare mock methods in an anonymous mock class as
   non-<code>public</code> (always).
   This is an added bonus over annotated (and named) mock classes, which often (but not always) need to be public with
   their mocks also public.
</p>

<h3 id="interfaces">
   Mocking interfaces
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#setUp"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#stubs"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Most of the time a mock class targets a real class directly.
   But what if we need a mock object that implements a certain interface, to be passed to code under test?
   The two following example tests show how it is done, one using an annotated mock class, the other a mock-up class.
   The mocked interface is
   <a href="http://download.oracle.com/javase/6/docs/api/javax/security/auth/callback/CallbackHandler.html">
      javax.security.auth.callback.CallbackHandler</a>.
</p>
<pre><code>   @Test
   public void setUpMocksForInterface() throws Exception
   {
      CallbackHandler callbackHandler = Mockit.setUpMock(new MockCallbackHandler());

      callbackHandler.handle(new Callback[] {new NameCallback("Enter name:")});
   }

   @MockClass(realClass = CallbackHandler.class)
   public static class MockCallbackHandler
   {
      @Mock
      public void handle(Callback[] callbacks)
      {
         assertEquals(1, callbacks.length);
         assertTrue(callbacks[0] instanceof NameCallback);
      }
   }

   @Test
   public void mockInterfaceWithMockUp() throws Exception
   {
      CallbackHandler callbackHandler = new MockUp&lt;CallbackHandler>()
      {
         @Mock
         void handle(Callback[] callbacks)
         {
            assertEquals(1, callbacks.length);
            assertTrue(callbacks[0] instanceof NameCallback);
         }
      }.getMockInstance();

      callbackHandler.handle(new Callback[] {new NameCallback("Enter name:")});
   }
</code></pre>
<p>
   The <a href="../javadoc/mockit/Mockit.html#setUpMock(java.lang.Object)"><code>Mockit.setUpMock(Object)</code></a>
   method returns a proxy object that implements the desired interface, when the mock class
   specifies that interface as the value of the <code>realClass</code> attribute (if an actual class
   is specified in the attribute, the method will apply the mock class and return <code>null</code>).
   The method accepts either an instance of the annotated mock class or the <code class="type">Class</code>
   literal for the same.
   Again, a more elegant alternative is obtained with the use of a mock-up class, which provides
   the proxy instance through a call to the <code>getMockInstance()</code> method.
   This method returns <code>null</code> if the mocked type is not an interface.
</p>
<p>
   Notice that for the first test the mock class and its mock methods are declared to be
   <code>public</code> and must be so to avoid an <code class="type">IllegalAccessError</code>, while in the
   second test the mock-up class and the mock method <em>don't have</em> to be public (an anonymous
   class is always non-public anyway).
</p>

<h3 id="stubs">
   Specifying stubs with a mock class
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#interfaces"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#constraints"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   The <code class="annotation">@MockClass</code> annotation also gives us the ability to specify methods and/or
   constructors in the real class that should be <em>stubbed out</em> so they have no effect when
   called during a test.
   Stubbing out a method achieves the same result as mocking it with a mock method that does nothing, except for
   returning the default value according to the method return type when it's not <code>void</code>.
</p>
<p>
   The following example tests make use of this feature.
</p>
<pre><code>   @Test
   public void mockAndStubOutClassAccordingToSpecifiedStubs() throws Exception
   {
      Mockit.setUpMocks(new MockLoginContextWithStubs());

      LoginContext context = new LoginContext("");
      context.login();
      context.logout();
   }

   @MockClass(realClass = LoginContext.class, stubs = {"(String)", "logout"})
   final class MockLoginContextWithStubs
   {
      @Mock
      void login() {} // this could also have been an stub
   }

   @Test
   public void mockAndStubOutClassAccordingToSpecifiedInverseStubs() throws Exception
   {
      Mockit.setUpMocks(MockLoginContextWithInverseStubs.class);

      LoginContext context = new LoginContext("", null, null);
      context.login();
      context.logout();
   }

   @MockClass(realClass = LoginContext.class, stubs = "", inverse = true)
   static class MockLoginContextWithInverseStubs
   {
      @Mock
      static void login() {}
   }
</code></pre>
<p>
   In the first test above, the constructor of the real class (<code class="type">LoginContext</code>) which has
   one parameter of type <code class="type">String</code> is stubbed out, as well as all methods in the same
   class with name <code>logout</code>. Parameters are ignored if not specified in the stub filter,
   so all overloads (in case there is more than one) with the same method name will be stubbed out.
</p>
<p>
   The second mock class, <code class="type">MockLoginContextWithInverseStubs</code>, uses the
   <code>inverse</code> attribute (which by default is <code>false</code>) to specify that all
   methods and constructors <em>not</em> matching the specified stub filters will be stubbed out.
   In this example, the list of stub filters contains only an empty filter which matches nothing, so everything in the
   real class is stubbed out. Any mocks defined in the mock class will override the stub, however.
</p>
<p>
   Each stub filter string specified with the <code>stubs</code> attribute can match any number of
   methods of the real class, since the initial part actually is a <em>regular expression</em> for method names.
   For constructors, this part is left empty since they have no names.
   The second part in a stub filter string, which can be empty for methods but never for
   constructors, is a comma-separated list of parameter type names, between parentheses.
   Each parameter type name either is the name of a primitive type, or a fully qualified reference type name.
   For convenience, it can be a <em>unique suffix</em> for such type names instead; this makes it
   easy to specify reference type names, since in most cases the package name can be omitted.
   Finally, as seen in the example above, the empty stub filter will match <em>no</em> methods or
   constructors in the real class, or <em>all</em> methods and constructors if used with <code>inverse = true</code>.
</p>

<h3 id="constraints">
   Invocation count constraints
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#stubs"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#initializers"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   All example tests shown so far only used JUnit/TestNG "asserts" to verify invocation arguments.
   This is the part of the API that extends conventional state-based testing to the data items
   exchanged between objects.
   Sometimes, though, we may want to verify if a given method/constructor in a dependency is invoked
   at all by the unit under test.
   We may also want to verify exactly how many invocations a given mock received during the
   execution of a test, or specify that the test should fail if more/less than a certain number of
   invocations occurs.
   For this, we can specify <em>declarative constraints</em> on the <em>invocation count</em> of a
   given mock, as the following example shows.
</p>
<pre><code>   @Test
   public void specifyInvocationCountConstraints() throws Exception
   {
      Mockit.setUpMock(LoginContext.class, new Object()
      {
         @Mock(minInvocations = 1)
         void $init(String name) { assertEquals("test", name); }

         @Mock(invocations = 1)
         void login() {}

         @Mock(maxInvocations = 1)
         void logout() {}
      });

      new LoginContext("test").login();
   }
</code></pre>
<p>
   (In the test above we used an anonymous mock class with the <code>setUpMock</code> method,
   although a nicer solution could be obtained with a local <code class="type">MockUp</code> object.)
   In this test we used all three attributes of the <code class="annotation">@Mock</code> annotation related to
   invocation counts.
   The first mock specifies that the <code>LoginContext(String)</code> constructor must be invoked
   <em>at least once</em> during the test.
   The second one specifies that the <code>login()</code> method must be invoked <em>exactly once</em>, while the third
   declares that <code>logout()</code> <em>can</em> be invoked, but not more than once.
</p>
<p>
   It is also valid to specify both <code>minInvocations</code> and <code>maxInvocations</code> on
   the same mock, in order to constrain the invocation count to a given range.
</p>

<h3 id="initializers">
   Mocking and stubbing class initializers
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#constraints"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#instantiation"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   When a class in production code performs some work in one or more <em>static initialization blocks</em>, we often
   need to stub it out so it doesn't interfere with test execution.
   To do just that for a given real class, we can write something like
   <code><span class="annotation">@MockClass</span>(realClass = MyRealClass.class, <strong>stubs = "&lt;clinit>"</strong>)</code>.
   If we instead want some test code to execute when the static initialization of the real class
   gets executed by the JVM, then we can define an special mock, as shown below.
</p>
<pre><code>   @Test
   public void mockStaticInitializer()
   {
      new MockUp&lt;ClassWithStaticInitializers>()
      {
         @Mock(invocations = 1)
         void $clinit()
         {
            // Do something here.
         }
      };

      ClassWithStaticInitializers.doSomething();
   }
</code></pre>
<p>
   We can even verify that static initialization occurs, as specified by the invocation count
   constraint above. Notice however that once loaded by the JVM, a class will be initialized no more
   than once, so the test would fail if it runs after the class has already been initialized.
</p>

<h3 id="instantiation">
   Controlling the instantiation of mock classes
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#initializers"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#it"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   We have already seen two different situations when mock classes get instantiated:
</p>
<ol>
   <li>
      The mock class is instantiated directly by test code with the <code>new</code> operator, and passed to JMockit in
      a call to a <code>Mockit.setUpMock</code> or <code>Mockit.setUpMocks</code> method, or alternatively as a
      <code>MockUp</code> subclass instance.
      In this case the same mock instance is used for all calls to instance mock methods, as long as the mock class
      remains in effect.
   </li>
   <li>
      The mock class is instantiated "behind the covers" by JMockit whenever it needs an instance to invoke an instance
      mock method on.
      In this situation a mock instance is created, a mock is executed on it, and then it is discarded (that is, it
      becomes eligible for garbage collection).
   </li>
</ol>
<p>
   Sometimes it may be important to have more control on when exactly a mock class is automatically instantiated by
   JMockit.
   There is also a situation which is not covered by the previously described instantiation mechanisms, and which may be
   needed or useful for certain test cases: <em>instantiation per mocked instance</em>.
   To cover such needs the <code class="annotation">@MockClass</code> annotation has an <code>instantiation</code>
   attribute, whose values are given by the
   <a href="../javadoc/mockit/Instantiation.html"><code>Instantiation</code></a> "enum".
   The default value for this attribute is <code>Instantiation.PerMockInvocation</code>.
</p>
<p>
   The following sub-sections describe each of the possible instantiation modes which can be used
   to control how and when JMockit creates automatic mock class instances.
   Notice this is applicable only to situation 2 above.
</p>

<h4 id="PerMockSetup">Instantiation per Mock Setup</h4>
<p>
   For a mock class annotated as
   <code><span class="annotation">@MockClass</span>(realClass = ..., <strong>instantiation = PerMockSetup</strong>)</code>,
   a call like <code>Mockit.setUpMock(realClass, MyMockClass.class)</code> or
   <code>Mockit.setUpMocks(MyMockClass.class)</code> will result in the creation of the mock
   instance at the time of the call.
   This single mock instance will then be used for all instance method invocations, for as long as
   the mock class remains in effect.
</p>
<p>
   Notice this is equivalent to passing an instance created by test code in one of those mock setup calls.
</p>

<h4 id="PerMockInvocation">Instantiation per Mock Invocation</h4>
<p>
   For a mock class annotated as
   <code><span class="annotation">@MockClass</span>(realClass = ..., <strong>instantiation = PerMockInvocation</strong>)</code>,
   a call like <code>Mockit.setUpMock(realClass, MyMockClass.class)</code> or
   <code>Mockit.setUpMocks(MyMockClass.class)</code> will <em>not</em> result in the creation of any
   mock instance at this time, but will later if and when an instance mock method needs to be invoked.
   For each such invocation, a new mock instance is created and then discarded as soon as the mock call terminates.
</p>
<p>
   Notice this is the default JMockit behavior when a class literal for the mock class is passed in
   a mock setup call, and the <code>instantiation</code> attribute isn't specified.
</p>

<h4 id="PerMockedInstance">Instantiation per Mocked Instance</h4>
<p>
   For a mock class annotated as
   <code><span class="annotation">@MockClass</span>(realClass = ..., <strong>instantiation = PerMockedInstance</strong>)</code>,
   a call like <code>Mockit.setUpMock(realClass, MyMockClass.class)</code> or
   <code>Mockit.setUpMocks(MyMockClass.class)</code> will result in the <em>on-demand</em> creation
   of one new mock instance for each and every new <em>mocked instance</em> (ie, an instance of the real class).
   In other words, once the mock class is in effect, whenever a mocked instance method of the real
   class is invoked, a paired instance of the mock class will be created if none yet exists for that
   particular instance of the real class; this same mock instance will then be used for all
   invocations to mock instance methods.
</p>
<p>
   The ability to have a mock class instance for each real class instance will normally only be
   useful if the mock class stores some state that is specific to each instance of the real class.
</p>
<p>
   Notice the mock object lifetime described above can only be achieved by using this particular instantiation mode.
</p>

<h3 id="it">
   Accessing the mocked object: the "it" field
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#instantiation"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#reentrant"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   As we have seen, there is a relationship between <em>mocked instances</em> (that is, instances of
   real classes which have been mocked) and <em>mock instances</em> (instances of mock classes).
   Mock instances can be created explicitly in test code, or automatically by JMockit according to
   the instantiation mode of the mock class.
   Mocked instances are created inside tested code, or in test code so they can be passed to tested code.
</p>
<p>
   For certain use cases, a mock method executing on a mock instance may need access to the
   corresponding mocked instance.
   This can be achieved by declaring an instance field of name <strong><code>it</code></strong> in
   the mock class, with the type of the mocked real class.
   Every time a mocked instance method is redirected to execute the corresponding mock instance
   method, the <code>it</code> field on the mock instance will be set to the mocked instance.
   If a mocked <em>constructor</em> has a corresponding <code>$init</code> mock method, then the
   field will be set to the newly created (and uninitialized) instance.
</p>
<p>
   In practice, the use of an <code>it</code> field by itself is uncommon, so the following example
   test is a contrived (although interesting) one. The next section describes a more likely use for such fields.
</p>
<pre><code>   @Test
   public void accessMockedInstanceThroughItField() throws Exception
   {
      final Subject testSubject = new Subject();

      new MockUp&lt;LoginContext>()
      {
         <strong>LoginContext it;</strong>

         @Mock(invocations = 1)
         void $init(String name, Subject subject)
         {
            assertNotNull(name);
            assertSame(testSubject, subject);
            setField(it, subject); // forces setting of private Subject field, since no setter is available
         }

         @Mock(invocations = 1)
         void login()
         {
            assertNull(it.getSubject()); // getSubject() returns null until the subject is authenticated
            setField(it, "loginSucceeded", true); // private field set to true when login succeeds
         }

         @Mock(invocations = 1)
         void logout()
         {
            assertSame(testSubject, it.getSubject());
         }
      };

      LoginContext theMockedInstance = new LoginContext("test", testSubject);
      theMockedInstance.login();
      theMockedInstance.logout();
   }
</code></pre>
<p>
   The example above (which is an actual test in JMockit's own test suite) used a mock-up class, but
   annotated and regular anonymous mock classes can also declare an <code>it</code> field.
   The <code>setField</code> methods used in this test are statically imported from the
   <code class="type">mockit.Deencapsulation</code> utility class, and are only used here to make the test more
   meaningful.
   The local variable <code>theMockedInstance</code> contains the instance which the <code>it</code>
   field will be set to on the mock-up instance, for each of the three mock invocations in this particular test.
</p>

<h3 id="reentrant">
   Reentrant mocks
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#it"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#reuse"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Usually, a <em>reentrant method</em> is one which can be re-entered once it is already executing.
   Recursive methods, for example, are typically reentrant.
   A <em>reentrant mock method</em> is similar, but instead of causing itself to be re-entered, it
   causes the corresponding <em>mocked</em> method to be re-entered; and when this happens the
   original code of the real method is executed, without going through the mock again.
</p>
<p>
   If the mock is an instance method mocking a real instance method, it will need access to the
   mocked instance in order to call back the mocked instance method.
   For this, the mock class will need to declare an appropriate <code>it</code> field.
</p>
<p>
   A mocked method which has a reentrant mock will have different behavior than if it had a regular
   mock, so we use the <code><span class="annotation">@Mock</span>(<strong>reentrant = true</strong>)</code> annotation
   attribute to tell JMockit about our intentions.
   The example test below exercises a <code class="type">LoginContext</code> object created normally (without any
   mocking in effect at creation time), using an unspecified <code>configuration</code>.
   (For the complete version of the test, see the
   <a href="http://code.google.com/p/jmockit/source/browse/trunk/main/test/mockit/MockAnnotationsTest.java">
      <code>mockit.MockAnnotationsTest</code></a> class.)
</p>
<pre><code>   @Test
   public void reenterMockedMethodsThroughItField() throws Exception
   {
      // Create objects to be exercised by the code under test:
      LoginContext loginContext = new LoginContext("test", null, null, configuration);

      // Set up mocks:
      ReentrantMockLoginContext mockInstance = new ReentrantMockLoginContext();

      // Exercise the code under test:
      assertNull(loginContext.getSubject());
      <strong>loginContext.login();</strong>
      assertNotNull(loginContext.getSubject());
      assertTrue(mockInstance.loggedIn);

      mockInstance.ignoreLogout = true;
      <strong>loginContext.logout();</strong> // first entry, won't re-enter
      assertTrue(mockInstance.loggedIn);

      mockInstance.ignoreLogout = false;
      <strong>loginContext.logout();</strong> // second entry, will re-enter
      assertFalse(mockInstance.loggedIn);
   }

   static final class ReentrantMockLoginContext extends MockUp&lt;LoginContext>
   {
      LoginContext <strong>it</strong>;
      boolean ignoreLogout;
      boolean loggedIn;

      @Mock(<strong>reentrant = true</strong>)
      void login() throws LoginException
      {
         try {
            <strong>it.login();</strong> // re-enters the mocked method, executing the real code
            loggedIn = true;
         }
         finally {
            // This is here just to show that arbitrary actions can be taken inside the mock,
            // <em>before</em> and/or <em>after</em> the real method gets executed.
            System.out.println("Login attempted for " + it.getSubject());
         }
      }

      @Mock(<strong>reentrant = true</strong>)
      void logout() throws LoginException
      {
         // A reentrant mock execution can re-enter the mocked method <em>or not</em>, based on a condition.
         if (!ignoreLogout) {
            <strong>it.logout();</strong>
            loggedIn = false;
         }
      }
   }
</code></pre>
<p>
   In the example above, <em>all</em> real code exercised by the test actually gets executed, even though some methods
   (<code>login</code> and <code>logout</code>) are mocked.
   The example indeed is contrived; in practice, reentrant mocks would not normally be useful for <em>testing</em> per
   se, not directly at least.
</p>
<p>
   You may have noticed that a reentrant mock effectively behaves like <em>advice</em> (from AOP jargon) for the
   corresponding real method.
   This is a powerful ability that can be useful for certain things.
   JMockit itself uses mock classes containing reentrant mocks to provide integration with the JUnit and TestNG test
   runners.
</p>

<h3 id="reuse">
   Reusing mocks between tests
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocks"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#reentrant"><img align="right" src="go-up.png" title="Previous section"></a>
      <img align="right" src="blank.gif" width="22">
   </div>
</h3>
<p>
   Most tests will probably only use dedicated mock classes, specifically created for each particular test.
   There will be times, though, when the same mock class can be reused by multiple test methods,
   either in a single test class or across the entire test suite.
   We will now see different ways to set up mocks so they are shared by a whole group of tests, as
   well as ways to define reusable mock classes.
</p>

<h4 id="beforeAfter">Using before/after methods</h4>
<p>
   In a given test class, we can define instance methods that will run <em>before</em> and <em>after</em> each test
   method (even when the test throws an error or exception).
   In JUnit 3.8, these are the <code>setUp()</code> and <code>tearDown()</code> method overrides.
   In JUnit 4.x we use the <code class="annotation">@Before</code> and <code class="annotation">@After</code>
   annotations on one or more arbitrary instance methods of the test class. The same applies to the
   <code class="annotation">@BeforeMethod</code> and <code class="annotation">@AfterMethod</code> annotations of TestNG.
</p>
<p>
   Any mock class that can be applied from inside a test method can also be applied from a "before"
   method, using one of the "set-up" methods or by instantiating a mock-up class.
   Such a mock class will remain in effect for the execution of all test methods in the test class.
   The only difference of applying mocks in a "before" method is that they also remain in effect inside "after" methods,
   if any.
</p>
<p>
   For example, if we wanted to mock the <code class="type">LoginContext</code> class with a mock-up class for a bunch
   of related tests, we would have the following methods in the test class:
</p>
<pre><code>public class MyTestClass
{
   @Before
   public void setUpSharedMocks()
   {
      new MockUp&lt;LoginContext>()
      {
         // shared mocks here...
      };
   }

   // test methods that will share the mocks set up above...
}
</code></pre>
<p>
   If we had an annotated mock class instead of a mock-up, the set up would be done with a
   <code>Mockit.setUpMocks(NamedMockClass.class)</code> call or with a <code>Mockit.setUpMock</code> variant.
</p>
<p>
   The example above uses JUnit 4, but the equivalent code for JUnit 3.8 or TestNG would be almost the same.
</p>
<p>
   It is also valid to extend from base test classes, which may optionally define "before" and/or "after" methods
   containing calls to the Annotations API.
</p>

<h4 id="reusableMocks">Reusable mock classes</h4>
<p>
   Named mock classes of all kinds (annotated with <code class="annotation">@MockClass</code> or not, mock-up classes)
   can be designed as concrete (and optionally <code>final</code>) classes that are then used in specific tests.
   When instantiated directly by test code, such mock instances can be configured through constructor arguments, fields,
   or non-mock methods.
   Alternatively, they can be designed as base classes (possibly <code>abstract</code>) to be extended by concrete mock
   classes inside specific test classes or methods.
</p>
<p>
   The example tests for this section come from JMockit's own test suite. They exercise the following class, partially
   reproduced here:
</p>
<pre><code>public final class TextFile
{
   // fields and constructors that accept a TextReader or DefaultTextReader object...
   
   public List&lt;String[]> parse()
   {
      <strong>skipHeader();</strong>

      List&lt;String[]> result = new ArrayList&lt;String[]>();

      while(true) {
         String  strLine = <strong>nextLine();</strong>

         if (strLine == null) {
            <strong>closeReader();</strong>
            break;
         }

         String[] parsedLine = strLine.split(",");
         result.add(parsedLine);
      }

      return result;
   }

   // private helper methods that call "skip(n)", "readLine()", and "close()"...
   
   public interface <strong>TextReader</strong>
   {
      long skip(long n) throws IOException;
      String readLine() throws IOException;
      void close() throws IOException;
   }

   static final class <strong>DefaultTextReader</strong> implements TextReader
   {
      DefaultTextReader(String fileName) throws FileNotFoundException { ...mocked... }
      public long skip(long n) throws IOException { ...mocked... }
      public String readLine() throws IOException { ...mocked... }
      public void close() throws IOException { ...mocked... }
   }
}
</code></pre>
<p>
   Some of the tests for the class above are as follows.
</p>
<pre><code>public final class TextFileUsingMockUpsTest
{
   // A reusable mock-up class to be directly instantiated in specific tests.
   static final class <strong>MockTextReaderConstructor</strong> extends MockUp&lt;<strong>DefaultTextReader</strong>>
   {
      @Mock(invocations = 1)
      void $init(String fileName) { assertThat(fileName, equalTo("file")); }
   }

   @Test
   public void parseTextFileUsingDefaultTextReader() throws Exception
   {
      <strong>new MockTextReaderConstructor();</strong>
      <strong>new MockTextReaderForParse&lt;DefaultTextReader>() {};</strong>

      List&lt;String[]> result = new TextFile("file", 200).parse();

      // assert result from parsing
   }

   ...
</code></pre>
<p>
   The test above uses two reusable mock classes. The first one encapsulates a mock for the single constructor of the
   <code class="type">TextFile.DefaultTextReader</code> nested class.
   Any tests exercising code in the <code class="type">TextFile</code> class that invokes this constructor will
   therefore use this mock class.
   And since it is a mock-up class, it can be applied through simple instantiation inside the test method.
</p>
<p>
   The second mock class used by the test targets the same <code class="type">DefaultTextReader</code> class.
   As we see next, it defines mocks for a whole different set of members, which happen to be the methods called from
   the <code>TextFile#parse()</code> method.
</p>
<pre><code>   ...

   // A reusable base mock class to be extended in specific tests.
   static class <strong>MockTextReaderForParse&lt;T extends TextReader></strong> extends MockUp&lt;T>
   {
      static final String[] LINES = { "line1", "another,line", null};
      int invocation;

      @Mock(invocations = 1)
      long skip(long n)
      {
         assertEquals(200, n);
         return n;
      }

      @Mock(invocations = 3)
      String readLine() throws IOException { return LINES[invocation++]; }

      @Mock(invocations = 1)
      void close() {}
   }

   ...
</code></pre>
<p>
   The mock-up class above, like the <code class="type">mockit.MockUp&lt;T></code> class which it extends, is
   <em>generic</em>.
   In this particular case, this is necessary because the tested <code class="type">TextFile</code> class works
   with two different types for the "text reader" dependency:
   <code class="type">TextFile.TextReader</code> (an interface which client code can implement), and
   <code class="type">TextFile.DefaultTextReader</code> (an internal default implementation of the interface).
   The previous test simply used this mock class <em>as is</em>, by defining an anonymous subclass which specifies the
   type to be mocked as the <code class="type">DefaultTextReader</code> concrete class.
   The next test, on the other hand, passes a <code class="type">TextReader</code> implementation to
   <code class="type">TextFile</code>:
</p>
<pre><code>   ...

   @Test
   public void parseTextFileUsingProvidedTextReader() throws Exception
   {
      TextReader textReader = <strong>new MockTextReaderForParse&lt;TextReader>() {}</strong>.getMockInstance();

      List&lt;String[]> result = new TextFile(textReader, 200).parse();

      // assert result from parsing
   }

   ...
</code></pre>
<p>
   The interface implementation, in this case, is a mock proxy object obtained through the
   <code>MockUp&lt;T>#getMockInstance()</code> method.
</p>
<p>
   Finally, we get to a more interesting case, where the concrete mock subclass actually <em>overrides</em> some of the
   mocks inherited from the base mock class:
</p>
<pre><code>   ...

   @Test
   public void doesNotCloseTextReaderInCaseOfIOFailure() throws Exception
   {
      new MockTextReaderConstructor();
   
      <strong>new MockTextReaderForParse&lt;DefaultTextReader>()</strong>
      {
         <strong>@Override</strong> @Mock
         String readLine() throws IOException { <strong>throw new IOException();</strong> }

         <strong>@Override</strong> @Mock(<strong>invocations = 0</strong>)
         void close() {}
      };

      TextFile textFile = new TextFile("file", 200);

      try {
         textFile.parse();
         fail();
      }
      catch (RuntimeException e) {
         assertTrue(e.getCause() instanceof IOException);
      }
   }
}
</code></pre>
<p>
   The test forces an <code class="type">IOException</code> to be thrown in the first call to <code>readLine()</code>.
   (This exception will get wrapped in a <code class="type">RuntimeException</code> by the <code>parse</code> method.)
   It also specifies, through an invocation count constraint, that the <code>close()</code> method should never be
   called.
   This shows that not only the behavior of the inherited mock is overridden, but also any of the metadata specified
   through the <code class="annotation">@Mock</code> annotation.
</p>
<div class="navigation">
   <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
   <a href="ReflectionUtilities.html"><img align="right" src="go-next.png" title="Next chapter"></a>
   <a href="BehaviorBasedTesting.html"><img align="right" src="go-previous.png" title="Previous chapter"></a>
</div>
<br/>
</body>
</html>
