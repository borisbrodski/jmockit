<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
</head>
<body>
<h2>
   Measuring code coverage with JMockit Coverage
   <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
</h2>

<p>
   <a href="http://en.wikipedia.org/wiki/Code_coverage"><em>Code coverage</em></a> is a software
   metric that can tell you how much of the production code is covered by a given test suite.
   It's purely quantitative, and does not say anything about the <em>quality</em> of either the
   production code or the test code. That said, the examination of code coverage reports will
   sometimes lead to the discovery of unreachable code which can be eliminated. But more
   importantly, such reports can be used as a guide for the discovery of missing tests.
   This is not only useful when creating tests for existing production code, but also when writing
   tests first, such as in the practice of TDD (Test Driven Development).
</p>
<p>
   A <em>branching point</em> exists wherever the program makes a decision between two possible
   execution paths to follow.
   Any line of code containing a logical condition will be divided in at least two segments, each
   belonging to a separate branch.
   Each branch contains a <em>basic block</em>, which is a sequence of statements which always runs
   from first to last statement (ignoring exceptions or errors that may get thrown along the way, of
   course).
   Each <em>executable line</em> of source code contains one or more basic blocks <em>segments</em>.
   A segment simply is the part of the basic block that is confined to a single line.
</p>
<p>
   JMockit Coverage shows a line of source code as fully covered only if all of its basic block
   segments were executed at least once during the test run.
   Lets say that <code>ns >= 1</code> is the number of segments belonging to different basic blocks
   in a given executable line.
   If <code>ne</code> is the number of segments in that line which were executed at least once
   during a test run, then we can calculate the <em>coverage percentage</em> for that line as
   <code>ne / ns * 100</code>.
   From this percentage obtained for each executable line of code, a coverage percentage for the
   source file can also be calculated, and likewise for the whole Java package.
</p>
<p>
   An example coverage report is shown <a href="../coverage-sample/index.html">here</a>.
</p>
<p>
   There are three ways to control whether code coverage metrics are gathered or not for a given
   test run, and which kind of output should be generated at the end: through the classpath, through
   system properties, and through JVM parameters.
   The three ways can be combined and used at the same time for a given test run, so there is a lot
   of flexibility to configure what JMockit Coverage will do.
   In any case, <code>jmockit.jar</code> (or a versioned jar obtained from the
   <a href="http://download.java.net/maven/2/mockit/jmockit/">Maven repository</a>) does
   <em>not</em> need to be present in the classpath, unless of course the suite contains tests which
   use the JMockit API.
</p>

<h3 id="output">
   Available types of coverage output
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#jars"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   The JMockit Coverage tool can generate the following types of output:
</p>
<ol>
   <li>
      XHTML reports: a multi-page XHTML report is written in the "coverage-report" directory, under
      the current working directory. The directory is created if it doesn't yet exist; its contents
      are overwritten if previously generated.
      The report will include pages containing all Java source files covered by the test suite.
      By default, the tool looks for ".java" source files inside all directories of name "src" found
      directly or indirectly under the current working directory.
      Any intermediate sub-directories between "src" and the top-level package directory, such as
      "src/java" for example, will also be searched.
   </li>
   <li>
      XML files: a single XML output file of name "coverage.xml" is written under the current
      working directory. If the file already exists it is overwritten.
   </li>
   <li>
      Coverage data files: a single serialized file of name "coverage.ser" is written under the
      current working directory.
      Differently from the other cases, however, if the file already exists its contents are first
      read and <em>merged</em> with the in-memory results of the current test run.
      In the end, the file is re-written with the merged coverage data.
   </li>
</ol>
<p>
   For the first two types of output, there is optional "call point" information which may be
   included or not, as selected by the user.
   A <em>call point</em> is the point in the source test code from which an specific line of
   production code was exercised.
   Note that generating coverage with this extra information takes more time and produces
   significantly larger output. On the other hand, it can be useful to know which lines of test code
   caused a given line of production code to be executed during the test run. The XHTML report, in
   particular, makes this information easily viewable, though hiding it at first.
</p>
<p>
   If a different output directory is desired, it can be specified for a particular test run through
   the <code>jmockit-coverage-outputDir</code> <em>system property</em>.
   How this property is defined will depend on the mechanism used to run the test suite.
   If using the command line or a Java IDE, it can be specified through the "-D" JVM parameter.
   Inside an Ant or Maven build configuration file, a <code>&lt;property></code> element would be
   used (for Maven 2, it would probably be specified in the "maven-surefire-plugin" configuration).
</p>

<h3 id="jars">
   Controlling coverage through the classpath
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#output"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#systemProperties"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   This mechanism applies when the <code>-javaagent:jmockit.jar</code> JVM parameter is <em>not</em>
   used for running tests with JMockit. As such, it's only valid when running on JDK 1.6. (See the
   <a href="RunningTests.html">relevant chapter</a> for details.)
</p>
<p>
   To have code coverage output generated for a test run, add at least one of the following jar
   files to the classpath:
</p>
<ul>
   <li>
      <code>jmockit-coverage-<strong>htmlbasic</strong>.jar</code>:
      generates an XHTML report in the "coverage-report" directory, without call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>htmlfull</strong>.jar</code>:
      generates an XHTML report in the "coverage-report" directory, with call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>xmlbasic</strong>.jar</code>:
      generates an XML output file of name "coverage.xml", without call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>xmlfull</strong>.jar</code>:
      generates an XML output file of name "coverage.xml", with call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>merge</strong>.jar</code>:
      generates a merged data file of name "coverage.ser".
   </li>
</ul>
<p>
   The "htmlbasic" and "htmlfull" jars are mutually exclusive, and the same holds for "xmlbasic" and
   "xmlfull".
   However, it <em>is</em> valid to have one of each pair in the classpath at the same time.
   For example, if "htmlbasic" and "xmlfull" are both added to the classpath, at the end of the test
   run both a "coverage.xml" file and a "coverage-report" directory will be written.
</p>
<p>
   Each one of these <em>output specification jars</em> is empty except for the standard
   <code>META-INF/MANIFEST.MF</code> file.
   Still, they depend on <strong><code>jmockit-coverage.jar</code></strong> and this is specified
   through the <code>Class-Path</code> property inside <code>MANIFEST.MF</code>.
   Consequently, if this last jar file is available in the same directory then it does not need to
   be explicitly added to the classpath; otherwise, it (or an equivalent jar from the Maven
   repository) will need to be added.
</p>
<p>
   If none of the output specification jars is added to the classpath, but
   <code>jmockit-coverage.jar</code> is, then the "htmlbasic" report will be generated.
</p>

<h3 id="systemProperties">
   Controlling coverage through system properties
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#jars"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#jvmParameters"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   To have control over all aspects of the code coverage tool, set one or more
   <em>system properties</em> for the JVM instance that will run the test suite.
   Note that you should be able to do this inside an Ant target, a Maven <code>surefire</code>
   plugin configuration, or a test run configuration for your Java IDE of choice, using either
   JUnit or TestNG.
</p>
<p>
   The available system properties are:
</p>
<ol>
   <li>
      <code>jmockit-coverage-<strong>output</strong></code>: one or more comma-separated values
      between <code>xml</code>, <code>xml-nocp</code>, <code>html</code>, <code>html-nocp</code>,
      and <code>merge</code>.
   </li>
   <li>
      <code>jmockit-coverage-<strong>outputDir</strong></code>: absolute or relative path to the
      output directory, to be used for writing any "coverage.xml", "coverage.ser", and "index.html"
      files (plus the remaining ".html" files of the XHTML report, in automatically created
      sub-directories).
   </li>
   <li>
      <code>jmockit-coverage-<strong>srcDirs</strong></code>: comma-separated list of Java source 
      directories to be searched when generating an XHTML report.
      Each directory is specified by an absolute or relative path.
   </li>
   <li>
      <code>jmockit-coverage-<strong>classes</strong></code>:
      a <code>java.util.regex</code>-conformable regular expression which will be used to select
      the classes from production code which are considered for coverage.
   </li>
</ol>

<h3 id="jvmParameters">
   Controlling coverage through JVM parameters
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#systemProperties"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#merging"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Another way to have full control over the code coverage tool is to use a JVM command line with
   <code>-javaagent:jmockit.jar=coverage=&lt;Coverage arguments></code> when running the test suite.
   Note that you should be able to do this inside an Ant target or in a test run configuration for
   your Java IDE of choice, using either JUnit or TestNG.
</p>
<p>
   The "<code>Coverage arguments</code>" part consist of up to four different arguments, in the
   format <code>classSelectionRegex:outputFormat:outputDir:srcDirs</code>, as follows.
   Each of these four arguments has a sensible default, so that you won't always have to specify
   them all.
</p>
<ol>
   <li>
      <code>classSelectionRegex</code> specifies the classes to be selected for coverage;
      if empty, coverage will be applied only to the classes defined in the packages which
      contain the tests actually executed.
   </li>
   <li>
      <code>outputFormat</code> specifies the format for the coverage output, and should be
      one or more of: <code>xml</code>, <code>xml-nocp</code>, <code>html</code>,
      <code>html-nocp</code>, <code>merge</code>; more than one value can be specified by separating
      them with a comma; if no value is specified, <code>html-nocp</code> is assumed.
   </li>
   <li>
      <code>outputDir</code> specifies the destination directory for coverage output;
      if empty, the current working directory is assumed, with a "coverage-report"
      subdirectory being created for the XHTML report (if not already existing).
   </li>
   <li>
      <code>srcDirs</code> is only applicable to the XHTML report, and is a comma-separated
      list of Java source directories;
      if empty, all "src" directories under the current working dir are automatically found
      and searched for ".java" sources.
   </li>
</ol>
<p>
   The <code>classSelectionRegex</code> argument should be a
   <code>java.util.regex</code>-conformable regular expression specifying the classes and/or
   packages in production code for which coverage is desired.
   For example, "orderMngr.domain.*" selects all classes in the <code>orderMngr.domain</code>
   package as well as in any sub-packages.
</p>
<p>
   In the <code>outputFormat</code> specifier, the "-nocp" suffix stands for "no call points",
   meaning that information on call points will not be included, which usually makes the output much
   smaller.
   Notice that both types (XML and XHTML) of output can be specified; if both variants for the same
   type are specified, for example "xml,xml-nocp", then the first occurrence will take precedence.
</p>

<h3 id="merging">
   Generating aggregate reports for separate test runs
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#jvmParameters"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#maven"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Suppose you have multiple test run configurations (in separate Ant targets, for example), and
   you want to generate a single XHTML report for the production code covered by the full set of
   tests.
   Normally, when JMockit Coverage generates a report at the end of a test run, it overwrites any
   previous report that may have been generated in the same output directory.
   So, instead of getting an aggregate report as desired, you would end up with the report for the
   last test run only (assuming all test runs used the same working dir).
   Here is where the third type of output, the <em>merged data file</em> (coverage.ser), comes in.
</p>
<p>
   As seen in other sections, we activate the generation of this file by either adding
   <code>jmockit-coverage-merge.jar</code> to the classpath or by using a JVM command line such as
   "<code>-javaagent:jmockit.jar=coverage=:html,merge</code>".
</p>
<p>
   At the end of any test run, and <em>before</em> any XML output file or XHTML report is generated,
   an existing "coverage.ser" file in the current working dir will be read, with the coverage data
   in it merged with the current in-memory coverage data.
   The modified in-memory data is then used in the generation of any XML/XHTML output, according to
   the output types which were specified for the test run.
</p>
<p>
   Note that these separate test runs may be for the <em>same</em> test suite, or for
   <em>different</em> test suites.
   The only thing in common between all test runs, if a single XHTML report or XML file is
   desired from them, is that the working directory should be the same.
   Otherwise, the shared "coverage.ser" file won't be found and a new "coverage.xml" file or
   "coverage-report" directory will be created.
   If different test runs <em>must</em> use different working dirs (perhaps because the source
   directories are not all under the same top-level directory, or for some other reason), then the
   "coverage.ser" file will have to be provided in each working dir by whatever means are available
   (for example, by moving the file through an Ant task, or by creating a link in the file system).
</p>

<h3 id="maven">
   Using JMockit Coverage in a Maven project
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#merging"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#switching"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   If you run tests with the "test" Maven goal, then you will need the following dependency in
   <code>pom.xml</code>:
</p>
<pre><code>      &lt;dependency>
         &lt;groupId>mockit&lt;/groupId>
         &lt;artifactId>jmockit-coverage&lt;/artifactId>
         &lt;version>${jmockit.version}&lt;/version>
         &lt;scope>runtime&lt;/scope> 
      &lt;/dependency>
</code></pre>
<p>
   Notice that it will probably be useful to define a property for the JMockit version in use:
</p>
<pre><code>   &lt;properties>
      &lt;jmockit.version>0.993&lt;/jmockit.version> 
   &lt;/properties>
</code></pre>
<p>
   In Maven 2, the <code>surefire</code> plugin is the one usually responsible for actually running
   tests.
   To configure JMockit Coverage through JVM parameters, add something like the following:
</p>
<pre><code>&lt;plugin>
   &lt;groupId>org.apache.maven.plugins&lt;/groupId>
   &lt;artifactId>maven-surefire-plugin&lt;/artifactId>
   &lt;configuration>
      &lt;argLine>
         -javaagent:"${settings.localRepository}"/mockit/jmockit/${jmockit.version}/jmockit-${jmockit.version}.jar=
coverage=:html:./target/coverage-report
      &lt;/argLine>
   &lt;/configuration>
&lt;/plugin>
</code></pre>
<p>
   A more convenient way to specify the output directory for files generated by JMockit Coverage
   ("coverage.xml", "coverage.ser", "index.html" and other XHTML pages) is to configure
   <code>surefire</code> with the <code>jmockit-coverage-outputDir</code> <em>system property</em>
   (which goes inside the <code>configuration</code> element shown above):
</p>
<pre><code>      &lt;systemProperties>
         &lt;property>
            &lt;name>jmockit-coverage-outputDir&lt;/name>
            &lt;value>target/my-coverage-report&lt;/value>
         &lt;/property>
      &lt;/systemProperties>
</code></pre>

<h3 id="switching">
   Turning coverage output on/off
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#maven"><img align="right" src="go-up.png" title="Previous section"></a>
      <img align="right" src="blank.gif" width="22">
   </div>
</h3>
<p>
   To facilitate switching on/off the generation of code coverage output, the
   <em>read-only status</em> of the relevant file is checked by JMockit at startup.
   The relevant file, always in the working directory, is "coverage.xml" for XML output and
   "coverage-report/index.html" for XHTML output. (Note that the working directory can usually be
   selected separately for each test run configuration in the Java IDE.)
   If said file is currently marked as read-only in the OS, then the corresponding output is not
   generated for the next test run.
</p>
<p>
   Notice that a Java IDE usually provides an easy mechanism to toggle the read-only status of a
   project file. In IntelliJ IDEA it is done by double clicking the status bar, with the desired
   file opened in the editor. In Eclipse there is a "Read only" check box in the "Properties" screen
   for the text file selected in the editor; this screen can be opened by typing "Alt + Enter".
</p>
</body>
</html>
