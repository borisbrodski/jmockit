<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
</head>
<body>
<h2>
   Measuring line and path coverage with JMockit Coverage
   <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
</h2>

<p>
   <a href="http://en.wikipedia.org/wiki/Code_coverage"><em>Code coverage</em></a> consists of a set
   of software metrics that can tell you how much of the production code is covered by a given test
   suite.
   It's purely quantitative, and does not say anything about the <em>quality</em> of either the
   production code or the test code. That said, the examination of code coverage reports will
   sometimes lead to the discovery of unreachable code which can be eliminated. But more
   importantly, such reports can be used as a guide for the discovery of missing tests.
   This is not only useful when creating tests for existing production code, but also when writing
   tests first, such as in the practice of TDD (Test Driven Development).
</p>
<p>
   JMockit Coverage provides two different and complementary code coverage metrics:
   <em>line coverage</em> and <em>path coverage</em>.
   An example coverage report showing both metrics can be found
   <a href="../coverage-sample/index.html">here</a>.
</p>

<h3 id="line">
   Line Coverage
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#path"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   The <em>line coverage</em> metric tells us how much of the <em>executable code</em> in a source
   file has been exercised by tests.
   Each executable line of code can be <em>uncovered</em>, <em>covered</em>, or
   <em>partially covered</em>.
   In the first case, <em>none</em> of the executable code in it was executed at all.
   In the second, <em>all</em> of the code was fully executed at least once.
   In the third case, only <em>part</em> of the executable code in the line was executed.
   This can happen, for example, with lines of code containing multiple logical conditions in a
   complex boolean expression.
   JMockit Coverage identifies all three cases, computing the <em>coverage percentage</em> for each
   executable line of code accordingly: <strong>0%</strong> for an uncovered line,
   <strong>100%</strong> for a covered line, or some value in between for a partially covered line.
</p>
<p>
   A <em>branching point</em> exists wherever the program makes a decision between two possible
   execution paths to follow.
   Any line of code containing a logical condition will be divided in at least two executable
   <em>segments</em>, each belonging to a separate <em>branch</em>.
   An executable line of source code with no branching points contains a single segment.
   Lines with one or more branching points contain two or more executable segments, separated by
   consecutive branching points in the line.
</p>
<p>
   Lets say that <code><strong>NS</strong> >= 1</code> is the number of executable segments on a
   given line.
   If <code><strong>NE</strong></code> is the number of segments in that line which were executed at
   least once during a test run (ie, they are <em>covered segments</em>), then we can calculate the
   coverage percentage for the line as <strong><code>100 * NE / NS</code></strong>.
</p>
<p>
   Similarly, the line coverage percentage for a whole source file is calculated from the total
   number of executable segments and the total number of covered segments, considering all
   executable lines of code in the file.
   The percentage for a <em>package</em>, in turn, is calculated from the total and covered numbers
   of segments in the whole set of source files belonging to the package.
   Finally, the <em>total code coverage</em> percentage is computed by the same formula on the
   totals for all packages.
</p>

<h3 id="path">
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#line"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#output"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
   Path Coverage
</h3>
<p>
   A completely different metric is <em>path coverage</em>, which is computed for method and
   constructor bodies, not for lines or segments of code.
   It tells us how many of the possible <em>execution paths</em> through a method or constructor,
   from <em>entry</em> to <em>exit</em>, have been executed at least once during the test run.
</p>
<p>
   Note that each method or constructor has a single point of entry, but can have multiple exits.
   An exit occurs when a <code>return</code> or <code>throw</code> statement is executed.
   These are <em>normal exits</em>, of course. A method/constructor execution can also terminate
   <em>abruptly</em>, by propagating an exception (or error) thrown as a result of a method call,
   an attempt to access a <code>null</code> reference, or some other action which caused an
   unintended program failure.
</p>
<p>
   Each possible path can be either fully executed (covered) or not (uncovered).
   Paths that execute only partially (ie, they were terminated abruptly) are simply considered as
   uncovered.
</p>
<p>
   The <em>path coverage percentage</em> for a method or constructor body is computed in a way
   similar to the line coverage computation.
   If <code><strong>NP</strong></code> is the number of possible paths through the implementation
   body and <code><strong>NPE</strong></code> is the number of paths executed from entry to exit,
   then the metric is computed as <strong><code>100 * NP / NPE</code></strong>.
   Also in the same way as the line coverage metric, we extend this formula to the whole source
   file, the whole package, and the whole set of packages touched by the test run.
</p>

<h3 id="output">
   Available types of coverage output
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#line"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#path"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#configuration"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   The JMockit Coverage tool can generate the following types of output:
</p>
<ol>
   <li>
      <strong>XHTML reports</strong>: a multi-page XHTML report is written in the "coverage-report"
      directory, under the current working directory (a different output directory can be specified
      if needed).
      The directory is created if it doesn't yet exist; its contents are overwritten if previously
      generated.
      The report will include pages containing all Java source files covered by the test suite.
      By default, the tool looks for ".java" source files inside all directories of name "src" found
      directly or indirectly under the current working directory; any intermediate sub-directories
      between "src" and the top-level package directory, such as "src/java" for example, are also
      searched.
   </li>
   <li>
      <strong>Coverage data files</strong>: a single serialized file of name "coverage.ser" is
      written under the current working directory or under an specified output directory.
      Differently from the other cases, however, if the file already exists its contents are first
      read and <em>merged</em> with the in-memory results of the current test run.
      In the end, the file is overwritten with the merged coverage data.
   </li>
</ol>

<h4 id="callPoints">Call points</h4>
<p>
   For the first two types of output, there is optional "call point" information which may be
   included or not, as selected by the user.
   A <em>call point</em> is the point in the source test code from which an specific line of
   production code was exercised.
   Note that generating coverage with this extra information takes more time and produces
   significantly larger output. On the other hand, it can be useful to know which lines of test code
   caused a given line of production code to be executed during the test run. The XHTML report, in
   particular, makes this information easily viewable, though hiding it at first.
</p>

<h3 id="configuration">
   Configuring the coverage tool
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#line"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#output"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#merging"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   First of all, to enable the JMockit Coverage tool at least one of several <em>coverage jars</em>
   needs to be added to the classpath.
   The main jar file, which contains all of the tool implementation code, is
   <code>jmockit-coverage.jar</code>.
   Adding any of the other <code>jmockit-coverage-xyz.jar</code> files to the classpath will result
   in having this one added implicitly (provided all jars are available in the same installation
   directory).
</p>
<p>
   Whatever the coverage jar(s) used, <code>jmockit.jar</code> (or a versioned jar obtained from the
   <a href="http://download.java.net/maven/2/mockit/jmockit/">Maven repository</a>) does
   <em>not</em> need to be added to the classpath, unless of course the suite contains tests which
   use the JMockit API (it will also be implicitly added to the classpath).
</p>
<p>
   Apart from enabling JMockit Coverage for a given test run, there are four aspects of the tool's
   behavior which can optionally be configured for the test run:
</p>
<ol>
   <li>
      The <strong>output format</strong> desired: an XHTML report, or a data file for merging of
      multiple test runs. Any combination of these three can be selected for the same test run.
      The default if none is specified is to generate a basic XHTML report.
   </li>
   <li>
      The <strong>output directory</strong> where output files should be written.
      By default, the current working directory of the running JVM is used.
   </li>
   <li>
      The list of <strong>source directories</strong> for the XHTML report.
      (This is not relevant for the serialized data file.)
      If no such directory is specified, all "src" directories under the current working directory
      will be considered.
   </li>
   <li>
      The set of Java classes which should be considered for coverage gathering.
      By default, all classes in production code loaded during the test run which are not inside jar
      files will be considered.
   </li>
</ol>

<h4 id="classpathConfiguration">Selecting the desired output through classpath configuration</h4>
<p>
   This mechanism applies when the <code>-javaagent:jmockit.jar</code> JVM parameter is <em>not</em>
   used for running tests with JMockit. As such, it's only valid when running on JDK 1.6. (See the
   <a href="RunningTests.html">relevant chapter</a> for details.)
</p>
<p>
   To select the desired output format(s) to be generated for a test run, add one or more of the
   following jar files to the classpath:
</p>
<ul>
   <li>
      <code>jmockit-coverage-<strong>htmlbasic</strong>.jar</code>:
      generates an XHTML report <em>without</em> call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>htmlfull</strong>.jar</code>:
      generates an XHTML report <em>with</em> call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>merge</strong>.jar</code>:
      generates a merged data file of name "coverage.ser".
   </li>
</ul>
<p>
   The "htmlbasic" and "htmlfull" jars are mutually exclusive.
   However, it <em>is</em> valid to have both <code>jmockit-coverage-merge.jar</code> and one of the
   two "html" jars in the classpath at the same time.
   In such a case, at the end of the test run both a "coverage.ser" file and a "coverage-report" 
   directory (unless another is specified) will be written.
</p>
<p>
   Each one of these <em>output specification jars</em> is empty except for the standard
   <code>META-INF/MANIFEST.MF</code> file.
   Still, they depend on <strong><code>jmockit-coverage.jar</code></strong> and this is specified
   through the <code>Class-Path</code> property inside <code>MANIFEST.MF</code>.
   Consequently, if this last jar file is available in the same directory then it does not need to
   be explicitly added to the classpath; otherwise, it (or an equivalent jar from the Maven
   repository) will need to be added.
</p>
<p>
   If none of the output specification jars is added to the classpath, but
   <code>jmockit-coverage.jar</code> is, then the "htmlbasic" report will be generated.
</p>

<h4 id="propertyConfiguration">Configuration through system properties</h4>
<p>
   To have control over all aspects of the code coverage tool, set one or more
   <em>system properties</em> for the JVM instance that will run the test suite.
   Note that you should be able to do this inside an Ant target, a Maven <code>surefire</code>
   plugin configuration, or a test run configuration for your Java IDE of choice, using either
   JUnit or TestNG.
</p>
<p>
   The available system properties are:
</p>
<ol>
   <li>
      <code>jmockit-coverage-<strong>output</strong></code>: one or more comma-separated values
      between <strong><code>html</code></strong>, <strong><code>html-nocp</code></strong>,
      and <strong><code>merge</code></strong>.
      The "nocp" suffix stands for "no call points".
      The use of this system property takes precedence over the presence of coverage jars in the
      classpath.
   </li>
   <li>
      <code>jmockit-coverage-<strong>outputDir</strong></code>: absolute or relative path to the
      output directory, to be used for writing any "coverage.ser" or "index.html" files (plus the
      remaining ".html" files of the XHTML report, in automatically created sub-directories).
   </li>
   <li>
      <code>jmockit-coverage-<strong>srcDirs</strong></code>: comma-separated list of Java source 
      directories to be searched when generating an XHTML report.
      Each directory is specified by an absolute or relative path.
   </li>
   <li>
      <code>jmockit-coverage-<strong>classes</strong></code>:
      a <code>java.util.regex</code>-conformable regular expression which will be used to select
      the classes from production code which are considered for coverage.
   </li>
   <li>
      <code>jmockit-coverage-<strong>excludes</strong></code>:
      a <code>java.util.regex</code>-conformable regular expression for class names which should be
      excluded from consideration when deciding which classes will be modified to gather coverage.
      This property can be used together with <code>jmockit-coverage-classes</code> or on its own.
   </li>
</ol>

<h4 id="javaagentConfiguration">Configuration through <code>-javaagent</code></h4>
<p>
   Another way to have full control over the code coverage tool is to use a JVM command line with
   <code>-javaagent:jmockit.jar=coverage=&lt;Coverage arguments></code> when running the test suite.
   Note that you should be able to do this inside an Ant target, a Maven <code>surefire</code>
   plug-in configuration, or in a test run configuration for your Java IDE of choice.
</p>
<p>
   The "<code>Coverage arguments</code>" part consist of up to four different arguments, in the
   format <code>classSelectionRegex:outputFormat:outputDir:srcDirs</code>, as follows.
   Each of these four arguments can be left unspecified by leaving it empty in the full string.
   After the last non-empty argument, the ":" characters can be omitted.
</p>
<ol>
   <li>
      <code>classSelectionRegex</code> specifies the classes to be selected for coverage;
      if empty, coverage will be gathered for all production classes loaded during the test which
      are not inside jar files.
   </li>
   <li>
      <code>outputFormat</code> specifies the format for the coverage output, and should be
      one or more of: <strong><code>html</code></strong>, <strong><code>html-nocp</code></strong>,
      <strong><code>merge</code></strong> ("nocp" stands for "no call points"); more than one value
      can be specified by separating them with a comma; if no value is specified,
      <code>html-nocp</code> is assumed by default.
   </li>
   <li>
      <code>outputDir</code> specifies the destination directory for coverage output;
      if empty, the current working directory is assumed, with a "coverage-report"
      subdirectory being created for the XHTML report (if not already existing).
   </li>
   <li>
      <code>srcDirs</code> is only applicable to the XHTML report, and is a comma-separated
      list of Java source directories;
      if empty, all "src" directories under the current working dir are automatically found
      and searched for ".java" sources.
   </li>
</ol>
<p>
   The <code>classSelectionRegex</code> argument should be a
   <code>java.util.regex</code>-conformable regular expression specifying the classes and/or
   packages in production code for which coverage is desired.
   For example, "orderMngr.domain.*" selects all classes in the <code>orderMngr.domain</code>
   package as well as in any sub-packages.
</p>
<p>
   Note that both types ("merge" and XHTML) of output can be specified; if both "<code>html</code>"
   and "<code>html-nocp</code>" are specified, the first occurrence will take precedence.
</p>
<p>
   When one of these four arguments is left unspecified, the equivalent
   <code>jmockit-coverage-xyz</code> system property will be respected, if specified.
   If the argument <em>is</em> specified, though, it will take precedence over the property.
</p>

<h3 id="merging">
   Generating aggregate reports for separate test runs
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#configuration"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#maven"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Suppose you have multiple test run configurations (in separate Ant targets, for example), and
   you want to generate a single XHTML report for the production code covered by the full set of
   tests.
   Normally, when JMockit Coverage generates a report at the end of a test run, it overwrites any
   previous report that may have been generated in the same output directory.
   So, instead of getting an aggregate report as desired, you would end up with the report for the
   last test run only (assuming all test runs used the same working dir).
   Here is where the third type of output, the <em>merged data file</em> (coverage.ser), comes in.
</p>
<p>
   As seen in other sections, we activate the generation of this file by either adding
   <code>jmockit-coverage-merge.jar</code> to the classpath or by using a JVM command line such as
   "<code>-javaagent:jmockit.jar=coverage=:html,merge</code>".
</p>
<p>
   At the end of any test run, and <em>before</em> any XHTML report is generated, an existing
   "coverage.ser" file in the current working dir will be read, with the coverage data in it merged
   with the current in-memory coverage data.
   The modified in-memory data is then used in the generation of the XHTML report, if it is enabled
   for the test run.
</p>
<p>
   Note that these separate test runs may be for the <em>same</em> test suite, or for
   <em>different</em> test suites.
   The only thing in common between all test runs, if a single XHTML report is desired from them, is
   that the working directory should be the same.
   Otherwise, the shared "coverage.ser" file won't be found and a new "coverage-report" directory
   will be created.
   If different test runs <em>must</em> use different working dirs (perhaps because the source
   directories are not all under the same top-level directory, or for some other reason), then the
   "coverage.ser" file will have to be provided in each working dir by whatever means are available
   (for example, by moving the file through an Ant task, or by creating a link in the file system).
</p>

<h3 id="maven">
   Using JMockit Coverage in a Maven project
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#line"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#merging"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#switching"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   If you run tests with the "test" Maven goal, then you will need the following dependency in
   <code>pom.xml</code>:
</p>
<pre><code>      &lt;dependency>
         &lt;groupId>mockit&lt;/groupId>
         &lt;artifactId>jmockit-coverage&lt;/artifactId>
         &lt;version>${jmockit.version}&lt;/version>
         &lt;scope>runtime&lt;/scope> 
      &lt;/dependency>
</code></pre>
<p>
   Notice that it will probably be useful to define a property for the JMockit version in use:
</p>
<pre><code>   &lt;properties>
      &lt;jmockit.version>0.995&lt;/jmockit.version> 
   &lt;/properties>
</code></pre>
<p>
   In Maven 2, the <code>surefire</code> plugin is the one usually responsible for actually running
   tests.
   To configure JMockit Coverage through JVM parameters, add something like the following:
</p>
<pre><code>&lt;plugin>
   &lt;groupId>org.apache.maven.plugins&lt;/groupId>
   &lt;artifactId>maven-surefire-plugin&lt;/artifactId>
   &lt;configuration>
      &lt;argLine>
         -javaagent:"${settings.localRepository}"/mockit/jmockit/${jmockit.version}/jmockit-${jmockit.version}.jar=
coverage=:html:./target/coverage-report
      &lt;/argLine>
   &lt;/configuration>
&lt;/plugin>
</code></pre>
<p>
   A more convenient way to specify the output directory for files generated by JMockit Coverage
   ("coverage.ser", "index.html" and other XHTML pages) is to configure <code>surefire</code> with
   the <code>jmockit-coverage-outputDir</code> <em>system property</em> (which goes inside the
   <code>configuration</code> element shown above):
</p>
<pre><code>      &lt;systemProperties>
         &lt;property>
            &lt;name>jmockit-coverage-outputDir&lt;/name>
            &lt;value>target/my-coverage-report&lt;/value>
         &lt;/property>
      &lt;/systemProperties>
</code></pre>

<h3 id="switching">
   Turning coverage output on/off
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#line"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#maven"><img align="right" src="go-up.png" title="Previous section"></a>
      <img align="right" src="blank.gif" width="22">
   </div>
</h3>
<p>
   To facilitate switching on/off the generation of code coverage output, the
   <em>read-only status</em> of the relevant file is checked by JMockit at startup.
   The relevant file, always in the working directory, is "coverage.ser" for serialized output and
   "coverage-report/index.html" for XHTML output. (Note that the working directory can usually be
   selected separately for each test run configuration in the Java IDE.)
   If said file is currently marked as read-only in the OS, then the corresponding output is not
   generated for the next test run.
</p>
<p>
   Notice that a Java IDE usually provides an easy mechanism to toggle the read-only status of a
   project file. In IntelliJ IDEA it is done by double clicking the status bar, with the desired
   file opened in the editor. In Eclipse there is a "Read only" check box in the "Properties" screen
   for the text file selected in the editor; this screen can be opened by typing "Alt + Enter".
</p>

<h4 id="jmockit-tools">Using the <code>jmockit-tools</code> system property</h4>
<p>
   Another way to switch coverage on/off is to use the <strong><code>jmockit-tools</code></strong>
   system property, which can specify the "startup tools", between those available in the classpath
   (if any), to be loaded by JMockit at startup.
   For the coverage tool, the word <strong>"coverage"</strong> must be present in the value
   specified for the property (which can contain two or more tool names separated by commas).
</p>
</body>
</html>
