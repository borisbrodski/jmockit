<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
</head>
<body>
<h2>
   Measuring code coverage with JMockit Coverage
   <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
</h2>

<p>
   <a href="http://en.wikipedia.org/wiki/Code_coverage"><em>Code coverage</em></a> is a software
   metric that can tell you how much of the production code is covered by a given test suite.
   It's purely quantitative, and does not say anything about the <em>quality</em> of either the
   production code or the test code. That said, the examination of code coverage reports will
   sometimes lead to the discovery of unreachable code which can be eliminated. But more
   importantly, such reports can be used as a guide for the discovery of missing tests.
   This is not only useful when creating tests for existing production code, but also when writing
   tests first, such as in the practice of TDD (Test Driven Development).
</p>
<p>
   There are several ways in which specific code coverage metrics can be defined.
   JMockit Coverage currently supports the two most well known metrics: <em>statement (or line)
   coverage</em>, and <em>branch coverage</em>.
   A <em>branch</em> exists wherever the program makes a decision between two possible execution
   paths to follow. Any line of code containing a logical condition will be divided in at least two
   segments, each belonging to a separate branch.
</p>
<p>
   JMockit Coverage combines statement and branch coverage, showing a line of source code as fully
   covered only if all statements contained in all branch segments in it were executed at least
   once.
   Lets say that <code>ns >= 1</code> is the number of segments belonging to different branches in a
   given line of source code which contains at least one executable statement.
   If <code>ne</code> is the number of branch segments in that line which were executed at least
   once during a test suite run, then we can calculate the <em>coverage percentage</em> for that
   line as <code>(ne / ns) * 100</code>.
   From this percentage obtained for each executable line of code, a coverage percentage for the
   source file can also be calculated, and likewise for the whole Java package.
</p>
<p>
   An example coverage report is shown <a href="../coverage-sample/index.html">here</a>.
</p>
<p>
   There are two ways to control whether code coverage metrics are gathered or not for a given test
   run, and which kind of output should be generated at the end: through the classpath, and through
   JVM parameters.
   In both cases, <code>jmockit.jar</code> (or an equivalent jar obtained from the
   <a href="http://download.java.net/maven/2/mockit/jmockit/">Maven repository</a>) needs to be
   present in the classpath.
</p>

<h3 id="output">
   Available types of coverage output
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#jars"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   The JMockit Coverage tool can generate the following types of output:
</p>
<ol>
   <li>
      XHTML reports: a multi-page XHTML report is written in the "coverage-report" directory, under
      the current working directory. The directory is created if it doesn't yet exist; its contents
      are overwritten if previously generated.
      The report will include pages containing all Java source files covered by the test suite.
      By default, the tool looks for ".java" source files inside all directories of name "src" found
      directly or indirectly under the current working directory.
      Any intermediate sub-directories between "src" and the top-level package directory, such as
      "src/java" for example, will also be searched.
   </li>
   <li>
      XML files: a single XML output file of name "coverage.xml" is written under the current
      working directory. If the file already exists it is overwritten.
   </li>
   <li>
      Coverage data files: a single serialized file of name "coverage.ser" is written under the
      current working directory.
      Differently from the other cases, however, if the file already exists its contents are first
      read and <em>merged</em> with the in-memory results of the current test run.
      In the end, the file is re-written with the merged coverage data.
   </li>
</ol>
<p>
   For the first two types of output, there is optional "call point" information which may be
   included or not, as selected by the user.
   A <em>call point</em> is the point in the source test code from which an specific line of
   production code was exercised.
   Note that generating coverage with this extra information takes more time and produces
   significantly larger output. On the other hand, it can be useful to know which lines of test code
   caused a given line of production code to be executed during the test run. The XHTML report, in
   particular, makes this information easily viewable, though hiding it at first.
</p>

<h3 id="jars">
   Controlling coverage through the classpath
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#output"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#jvm"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   This mechanism applies when the <code>-javaagent:jmockit.jar</code> JVM parameter is <em>not</em>
   used for running tests with JMockit. As such, it's only valid when running on JDK 1.6. (See the
   <a href="RunningTests.html">relevant chapter</a> for details.)
</p>
<p>
   To have code coverage output generated for a test run, add at least one of the following jar
   files to the classpath:
</p>
<ul>
   <li>
      <code>jmockit-coverage-<strong>htmlbasic</strong>.jar</code>:
      generates an XHTML report in the "coverage-report" directory, without call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>htmlfull</strong>.jar</code>:
      generates an XHTML report in the "coverage-report" directory, with call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>xmlbasic</strong>.jar</code>:
      generates an XML output file of name "coverage.xml", without call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>xmlfull</strong>.jar</code>:
      generates an XML output file of name "coverage.xml", with call points.
   </li>
   <li>
      <code>jmockit-coverage-<strong>merge</strong>.jar</code>:
      generates a merged data file of name "coverage.ser".
   </li>
</ul>
<p>
   The "htmlbasic" and "htmlfull" jars are mutually exclusive, and the same holds for "xmlbasic" and
   "xmlfull".
   However, it <em>is</em> valid to have one of each pair in the classpath at the same time.
   For example, if "htmlbasic" and "xmlfull" are both added to the classpath, at the end of the test
   run both a "coverage.xml" file and a "coverage-report" directory will be written.
</p>
<p>
   Each one of these <em>output specification jars</em> is empty except for the standard
   <code>META-INF/MANIFEST.MF</code> file.
   Still, they depend on <strong><code>jmockit-coverage.jar</code></strong> and this is specified
   through the <code>Class-Path</code> property inside <code>MANIFEST.MF</code>.
   Consequently, if this last jar file is available in the same directory then it does not need to
   be explicitly added to the classpath; otherwise, it (or an equivalent jar from the Maven
   repository) will need to be added.
</p>
<p>
   If none of the output specification jars is added to the classpath, but
   <code>jmockit-coverage.jar</code> is, then the "htmlbasic" report will be generated.
</p>

<h3 id="jvm">
   Controlling coverage through JVM parameters
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#switching"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#jars"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#merging"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   To have control over all aspects of the code coverage tool, use a JVM command line with
   <code>-javaagent:jmockit.jar=coverage=&lt;Coverage arguments></code> when running the test suite.
   Note that you should be able to do this inside an Ant target or in a test run configuration for
   your Java IDE of choice, using either JUnit or TestNG.
</p>
<p>
   The "<code>Coverage arguments</code>" part consist of up to four different arguments, in the
   format <code>classSelectionRegex:outputFormat:outputDir:srcDirs</code>, as follows.
   Each of these four arguments has a sensible default, so that you won't always have to specify
   them all.
</p>
<ol>
   <li>
      <code>classSelectionRegex</code> specifies the classes to be selected for coverage;
      if empty, coverage will be applied only to the classes defined in the packages which
      contain the tests actually executed.
   </li>
   <li>
      <code>outputFormat</code> specifies the format for the coverage output, and should be
      one or more of: <code>xml</code>, <code>xml-nocp</code>, <code>html</code>,
      <code>html-nocp</code>, <code>merge</code>; more than one value can be specified by separating
      them with a comma; if no value is specified, <code>html-nocp</code> is assumed.
   </li>
   <li>
      <code>outputDir</code> specifies the destination directory for coverage output;
      if empty, the current working directory is assumed, with a "coverage-report"
      subdirectory being created for the XHTML report (if not already existing).
   </li>
   <li>
      <code>srcDirs</code> is only applicable to the XHTML report, and is a comma-separated
      list of Java source directories;
      if empty, all "src" directories under the current working dir are automatically found
      and searched for ".java" sources.
   </li>
</ol>
<p>
   The <code>classSelectionRegex</code> argument should be a
   <code>java.util.regex</code>-conformable regular expression specifying the classes and/or
   packages in production code for which coverage is desired.
   For example, "orderMngr.domain.*" selects all classes in the <code>orderMngr.domain</code>
   package as well as in any sub-packages.
</p>
<p>
   In the <code>outputFormat</code> specifier, the "-nocp" suffix stands for "no call points",
   meaning that information on call points will not be included, which usually makes the output much
   smaller.
   Notice that both types (XML and XHTML) of output can be specified; if both variants for the same
   type are specified, for example "xml,xml-nocp", then the first occurrence will take precedence.
</p>

<h3 id="merging">
   Generating aggregate reports for separate test runs
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#jvm"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#switching"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Suppose you have multiple test run configurations (in separate Ant targets, for example), and
   you want to generate a single XHTML report for the production code covered by the full set of
   tests.
   Normally, when JMockit Coverage generates a report at the end of a test run, it overwrites any
   previous report that may have been generated in the same output directory.
   So, instead of getting an aggregate report as desired, you would end up with the report for the
   last test run only (assuming all test runs used the same working dir).
   Here is where the third type of output, the <em>merged data file</em> (coverage.ser), comes in.
</p>
<p>
   As seen in other sections, we activate the generation of this file by either adding
   <code>jmockit-coverage-merge.jar</code> to the classpath or by using a JVM command line such as
   "<code>-javaagent:jmockit.jar=coverage=:html,merge</code>".
</p>
<p>
   At the end of any test run, and <em>before</em> any XML output file or XHTML report is generated,
   an existing "coverage.ser" file in the current working dir will be read, with the coverage data
   in it merged with the current in-memory coverage data.
   The modified in-memory data is then used in the generation of any XML/XHTML output, according to
   the output types which were specified for the test run.
</p>
<p>
   Note that these separate test runs may be for the <em>same</em> test suite, or for
   <em>different</em> test suites.
   The only thing in common between all test runs, if a single XHTML report or XML file is
   desired from them, is that the working directory should be the same.
   Otherwise, the shared "coverage.ser" file won't be found and a new "coverage.xml" file or
   "coverage-report" directory will be created.
   If different test runs <em>must</em> use different working dirs (perhaps because the source
   directories are not all under the same top-level directory, or for some other reason), then the
   "coverage.ser" file will have to be provided in each working dir by whatever means are available
   (for example, by moving the file through an Ant task, or by creating a link in the file system).
</p>

<h3 id="switching">
   Turning coverage output on/off
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#output"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#merging"><img align="right" src="go-up.png" title="Previous section"></a>
      <img align="right" src="blank.gif" width="22">
   </div>
</h3>
<p>
   To facilitate switching on/off the generation of code coverage output, the
   <em>read-only status</em> of the relevant file is checked by JMockit at startup.
   The relevant file, always in the working directory, is "coverage.xml" for XML output and
   "coverage-report/index.html" for XHTML output. (Note that the working directory can usually be
   selected separately for each test run configuration in the Java IDE.)
   If said file is currently marked as read-only in the OS, then the corresponding output is not
   generated for the next test run.
</p>
<p>
   Notice that a Java IDE usually provides an easy mechanism to toggle the read-only status of a
   project file. In IntelliJ IDEA it is done by double clicking the status bar, with the desired
   file opened in the editor. In Eclipse there is a "Read only" check box in the "Properties" screen
   for the text file selected in the editor; this screen can be opened by typing "Alt + Enter".
</p>
</body>
</html>
