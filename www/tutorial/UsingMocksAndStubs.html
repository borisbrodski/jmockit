<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
</head>
<body>
<h2>Using mocks and stubs over entire test classes and suites</h2>

<p>
   As we have seen, the <a href="StateBasedTesting.html">JMockit Annotations API</a> provides
   methods that can be used to apply <em>mock classes</em> and to <em>stub out</em> classes.
   There are times when we want to mock or stub out classes for the entire scope of a test class
   (that is, for all of its test methods), or even for the entire scope of a test suite (that is,
   for all of its test classes).
   The <code>mockit.UsingMocksAndStubs</code> annotation provides an easy way to do just that, by
   letting us specify which mock classes to apply and/or which real classes to stub out for a given
   test class, and when JUnit 4 is used, for a given test suite class.
</p>
<div style="text-align: center;" title="Click for API documentation">
   <map name="figure1">
      <area shape="rect" coords="5,7,178,35" href="../javadoc/mockit/UsingMocksAndStubs.html">
   </map>
   <img src="UsingMocksAndStubs.png" usemap="#figure1">
</div>
<p>
   The <code>@UsingMocksAndStubs</code> annotation is applied to a test/suite class with a list
   containing one or more mock classes (themselves annotated with <code>@MockClass</code>) and/or
   production classes.
   When any test in this annotated test class/suite is executed, those mocks and stubs will be in
   effect.
</p>
<p>
   This ability is particularly useful to prevent code under test from executing some other code
   which is not relevant for the test but could interfere with it, or take too long to execute, or
   generate some undesirable output.
   The following example causes two dependency classes to be fully stubbed out, including any static
   initialization blocks they may have.
</p>
<pre><code>public class UnitUnderTest
{
   private final Dependency dep1 = new Dependency(...);

   public void doSomething()
   {
      ...
      AnotherDependency.staticMethod();
      ...
   }
}

@RunWith(JMockit.class)
@UsingMocksAndStubs({Dependency.class, AnotherDependency.class})
public final class UnitTest
{
   @Test
   public void someTestMethod()
   {
      new UnitUnderTest().doSomething();
   }
}
</code></pre>
<p>
   For a JUnit 4 test suite, we can apply a given mock class (and/or stub out production classes) by
   annotating the test suite class, as the next example shows.
</p>
<pre><code>@RunWith(Suite.class)
@Suite.SuiteClasses({MyFirstTest.class, MySecondTest.class})
@UsingMocksAndStubs({JDKLoggingMocks.class, Log4jMocks.class})
public final class TestSuite extends JMockitTest
{}
</code></pre>
<p>
   Notice that the above JUnit test suite class extends <code>JMockitTest</code>, to make sure that
   JMockit will get properly initialized (another way would be to call
   <code>Mockit.setUpMocks();</code> inside a <code>@BeforeClass</code> method of the suite class).
</p>
<p>
   In this example, we apply the <code>JDKLoggingMocks</code> and <code>Log4jMocks</code> mock
   classes, both available in the <code>mockit.integration.logging</code> package.
   With this, any use of the standard <code>java.util.logging</code> API in any test belonging to
   the specified test suite will be mocked/stubbed out so that no actual logging output is produced.
   Any calls in production code like <code>Logger.getLogger(ProductionClass.class.getName())</code>
   will result in a mock logger object.
   The same will happen to uses of the Log4J API.
</p>
<p>
   The implementation of the <code>mockit.integration.logging.Log4jMocks</code> class makes for some
   interesting and complex use of the state-based mocking/stubbing API, so we reproduce it here for
   reference (minus the Javadoc documentation).
</p>
<pre><code>import org.apache.log4j.*;
import org.apache.log4j.spi.*;

import mockit.*;
import static mockit.Instantiation.*;

@MockClass(
   realClass = Logger.class, instantiation = PerMockSetup, stubs = {"trace", "isTraceEnabled"})
public final class Log4jMocks
{
   private static final Logger MOCK_LOGGER = new RootLogger(Level.OFF);

   public Log4jMocks()
   {
      Mockit.stubOut(Category.class);
   }

   @Mock public static Logger getLogger(String name) { return MOCK_LOGGER; }
   @Mock public static Logger getLogger(Class<?> clazz) { return MOCK_LOGGER; }
   @Mock public static Logger getRootLogger() { return MOCK_LOGGER; }
   @Mock public static Logger getLogger(String name, LoggerFactory lf) { return MOCK_LOGGER; }
}
</code></pre>
<p>
   The Log4J API provides several static methods to create loggers, so we have a corresponding mock
   method for each one of them, which simply returns a global mock instance.
   The <code>@MockClass</code> annotation only accepts a single "real" class to be mocked, so we use
   the mock class constructor to stub out the <code>org.apache.log4j.Category</code> class, which
   <code>org.apache.log4j.Logger</code> extends.
   As specified in the <code>instantiation</code> attribute, this mock class will be instantiated
   with the default constructor once <em>per mock setup</em>, which in this case occurs when the
   <code>@UsingMocksAndStubs</code> annotation is applied to the test suite.
   We also specified two methods of the <code>Logger</code> class to be stubbed out.
</p>

<script type="text/javascript" src="../prettify.js"></script>
</body>
</html>
