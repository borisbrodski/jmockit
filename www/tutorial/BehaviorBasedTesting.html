<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>The JMockit Testing Toolkit Tutorial</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
   <script type="text/javascript" src="../highlight.pack.js"></script>
   <script type="text/javascript">hljs.initHighlightingOnLoad()</script>
</head>
<body>
<h2>
   Behavior-based testing with JMockit
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="StateBasedTesting.html"><img align="right" src="go-next.png" title="Next chapter"></a>
      <a href="RunningTests.html"><img align="right" src="go-previous.png" title="Previous chapter"></a>
   </div>
</h2>

<ol style="border: medium ridge; background-color: beige;">
   <li><a href="#mocked">Mocked types</a></li>
   <li><a href="#expectation">Expectations</a></li>
   <li><a href="#model">The <em>record-replay-verify</em> model</a></li>
   <li>
      <a href="#declaration">Declaring and using mocked types</a>
      <ol>
         <li><a href="#multipleInterfaces">Mocking multiple interfaces at the same time</a></li>
      </ol>
   </li>
   <li>
      <a href="#results">Recording results for an expectation</a>
      <ol>
         <li><a href="#defaultResults">Specifying default results</a></li>
      </ol>
   </li>
   <li><a href="#onInstance">Matching invocations to specific instances</a></li>
   <li>
      <a href="#hamcrest">Constraint-based matching of argument values</a>
      <ol>
         <li><a href="#matcherFields">Using the "any" <em>fields</em> for argument matching</a></li>
         <li><a href="#nullAsMatcher">Using the <code>null</code> value to match any object reference</a></li>
         <li><a href="#varargs">Matching values passed through a <em>varargs</em> parameter</a></li>
      </ol>
   </li>
   <li><a href="#constraints">Specifying invocation count constraints</a></li>
   <li>
      <a href="#strictness"><em>Strict</em> and <em>non-strict</em> expectations</a>
      <ol>
         <li><a href="#strictMocks">Strict and non-strict <em>mocks</em></a></li>
         <li><a href="#iteratedExpectations">Iterated expectations</a></li>
      </ol>
   <li>
      <a href="#verification">Explicit verification</a>
      <ol>
         <li><a href="#importingMocks">Importing mocks from expectation blocks</a></li>
         <li><a href="#neverHappened">Verifying that an invocation never happened</a></li>
         <li><a href="#VerificationInOrder">Verification in order</a></li>
         <li><a href="#partiallyOrdered">Partially ordered verification</a></li>
         <li><a href="#FullVerification">Full verification</a></li>
         <li><a href="#FullVerificationInOrder">Full verification in order</a></li>
         <li><a href="#restrictedFullVerifications">Restricting the set of mocked types to be fully verified</a></li>
         <li><a href="#emptyFullVerifications">Verifying that no invocations occurred</a></li>
         <li><a href="#unspecifiedInvocations">Verifying unspecified invocations that should not happen</a></li>
         <li><a href="#iterations">Verifying iterations</a></li>
      </ol>
   </li>
   <li><a href="#delegates">Delegates: specifying custom results and capturing arguments</a></li>
   <li><a href="#forEachInvocation">Validating invocation arguments</a></li>
   <li><a href="#deencapsulation">Accessing private fields, methods and constructors</a></li>
   <li>
      <a href="#partial">Partial mocking</a>
      <ol>
         <li><a href="#staticPartial">Static partial mocking</a></li>
         <li><a href="#dynamicPartial">Dynamic partial mocking</a></li>
      </ol>
   </li>
   <li><a href="#cascading">Cascading mocks</a></li>
   <li><a href="#capturing">Capturing internal instances of mocked types</a></li>
   <li><a href="#reuse">Reusing expectation and verification blocks</a></li>
</ol>

<p>
   In the JMockit toolkit, the <code>Expectations & Verifications</code> APIs provide rich support for the creation of
   <em>behavior-based</em> unit tests.
   The focus when doing this kind of testing is on the <em>interactions</em> between the unit under test and the other
   units it depends upon. Such units of behavior are the classes, methods, and constructors defined in production code.
</p>
<div style="text-align: center;">
   <map name="figure1">
      <area shape="rect" coords="38,84,172,117" href="../javadoc/mockit/Expectations.html">
      <area shape="rect" coords="2,166,208,199" href="../javadoc/mockit/NonStrictExpectations.html">
      <area shape="rect" coords="453,84,585,117" href="../javadoc/mockit/Verifications.html">
      <area shape="rect" coords="227,166,421,199" href="../javadoc/mockit/VerificationsInOrder.html">
      <area shape="rect" coords="440,166,598,199" href="../javadoc/mockit/FullVerifications.html">
      <area shape="rect" coords="617,166,838,199" href="../javadoc/mockit/FullVerificationsInOrder.html">
      <area shape="rect" coords="736,2,838,35" href="../javadoc/mockit/Delegate.html">
      <area shape="rect" coords="719,51,838,84" href="../javadoc/mockit/Invocation.html">
      <area shape="rect" coords="2,215,90,248" href="../javadoc/mockit/Tested.html">
      <area shape="rect" coords="108,215,223,248" href="../javadoc/mockit/Injectable.html">
      <area shape="rect" coords="298,215,392,248" href="../javadoc/mockit/Mocked.html">
      <area shape="rect" coords="411,215,518,248" href="../javadoc/mockit/NonStrict.html">
      <area shape="rect" coords="593,215,707,248" href="../javadoc/mockit/Cascading.html">
      <area shape="rect" coords="726,215,838,248" href="../javadoc/mockit/Capturing.html">
   </map>
   <img src="BehaviorBasedAPI.png" usemap="#figure1">
</div>
<p>
   An interaction between two units always takes the form of a method or constructor <em>invocation</em>.
   The set of invocations from a unit under test to its dependencies, together with the argument and
   return values passed between them, define the behavior of interest for the tests of that particular unit.
   In addition, a given test may need to verify the relative order of execution between multiple invocations.
</p>

<h3 id="mocked">
   Mocked types
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#expectation"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   The methods and constructors which are invoked from the unit under test, and which belong to a dependency of that
   unit, will be our regular targets for <em>mocking</em>.
   We tell JMockit what needs to be mocked by specifying <em>mocked types</em>.
   A mocked type should be the type of a dependency of the unit under test.
   Such a type can be any reference type: an interface, an abstract class, a concrete class, a <code>final</code> class,
   and so on (more on this later).
</p>
<p>
   By default, all methods and constructors (in case of a class) of the mocked type will be mocked.
   If the declared mocked type is a class, then all of its super-classes up to but not including
   <code>java.lang.Object</code> will also be mocked, recursively.
   Therefore, inherited methods will automatically be mocked as well.
</p>
<p>
   When a method or constructor is mocked, its original implementation code won't be executed on invocations from the
   test. Instead, the call will be redirected to JMockit so it can be dealt with in the manner that was explicitly or
   implicitly specified in the test method, as we will see in the remaining of this chapter.
</p>
<p>
   The following example test serves as a basic illustration for the declaration of mocked types.
   In this tutorial, we use many code snippets like this, where the parts in bold font are the current focus of
   explanation.
</p>
<pre><code>   @Test
   public void doBusinessOperationXyz()
   {
      ...

      new Expectations()
      {
         <strong>Dependency</strong> mockInstance; // "Dependency" is our mocked type for this test
         ...

         {
            ...
            <strong>mockInstance.mockedMethod(...);</strong>
            ...
         }
      };

      ...
   }
</code></pre>

<h3 id="expectation">
   Expectations
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#mocked"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#model"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   An <em>expectation</em> is a set of invocations to an specific mocked method/constructor that is relevant for a given
   test.
   An expectation may encompass multiple different invocations to the same method or constructor, but it does not have
   to encompass <em>all</em> such invocations that occur during the test execution.
</p>
<p>
   Besides being associated with an specific method or constructor, each expectation will specify argument values for
   the corresponding method/constructor invocations, when there are one or more invocation parameters involved.
   For each parameter, an exact argument value may be specified, according to the parameter type.
   For example, the value <code>"test string"</code> for an <code>String</code> parameter.
   As we will see later, instead of specifying exact argument values, we can specify constraints on such values, which
   will match whole sets of different argument values, for one or more actual invocations.
</p>
<p>
   The example below shows an expectation for <code>someMethod(int, String)</code>, which will match an invocation to
   this method that should receive the exact argument values as specified.
   Notice that the expectation itself is specified through an invocation to the mocked method.
   This invocation, however, does not count as one of the "real" invocations we are interested in testing.
   It's only there so that the expectation can be specified.
</p>
<pre><code>   @Test
   public void doBusinessOperationXyz()
   {
      ...

      new Expectations()
      {
         Dependency mockInstance;
         ...

         {
            ...
            // An expectation for an instance method:
            <strong>mockInstance.someMethod(1, "test");</strong>
            ...
         }
      };

      // A call to the unit under test occurs here, leading to the mock
      // invocations associated with one or more expectations.
   }
</code></pre>
<p>
   We will see more about expectations later, after we understand the differences between <em>recording</em> and
   <em>verifying</em> individual invocations.
</p>

<h3 id="model">
   The <em>record-replay-verify</em> model
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#expectation"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#declaration"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Any developer test can be divided in at least three separate execution <em>phases</em>.
   The phases execute sequentially, one at a time, as demonstrated below.
</p>
<pre><code>   @Test
   public void someTestMethod()
   {
      // 1. Preparation: whatever is required before the unit under test can be exercised.
      ...
      // 2. The unit under test is exercised, normally by calling a non-private method
      //    or constructor.
      ...
      // 3. Verification: whatever needs to be checked to make sure the exercised unit
      //    did its job.
      ...
   }
</code></pre>
<p>
   First, we have a preparation phase, where objects and data items needed for the test are created or obtained from
   somewhere else.
   Then, the unit under test is exercised. Finally, the results from exercising the tested unit are compared with the
   expected results.
</p>
<p>
   This model of three phases is also known as the <em>Arrange, Act, Assert syntax</em>, or "AAA" for short.
   Different words, but the meaning is exactly the same.
</p>
<p>
   In the context of behavior-based testing with mocks, we can identify the following alternative phases, which are
   directly related to the three previously described conventional testing phases.
</p>
<ol>
   <li>
      The <strong><em>record</em></strong> phase, during which invocations can be <em>recorded</em>.
      This happens during test preparation, <em>before</em> the invocations we want to test are executed.
   </li>
   <li>
      The <strong><em>replay</em></strong> phase, during which the mock invocations of interest have a chance to be
      executed, as the unit under test is exercised.
      The invocations to mocked methods/constructors previously recorded will now be <em>replayed</em>.
      Often there isn't a one-to-one mapping between invocations recorded and replayed.
   </li>
   <li>
      The <strong><em>verify</em></strong> phase, during which invocations can be <em>verified</em> to have occurred as
      expected or not.
      This happens during test verification, <em>after</em> the invocations under test had a chance to be executed.
   </li>
</ol>
<p>
   Behavior-based tests written with JMockit will typically look like the following:
</p>
<pre><code>import mockit.*;
... other imports ...

public class SomeTest
{
   // Zero or more "mock fields" common to all test methods in the class:
   @Mocked Collaborator mockCollaborator;
   @NonStrict AnotherDependency anotherDependency;
   ...

   @Test
   public void test1(mock parameters)
   {
      // Preparation code not specific to JMockit, if any.

      <strong>new Expectations()</strong> // an "expectation block"
      {
         // Zero or more mock fields.

         {
            // One or more invocations to mocked types, causing expectations to be recorded.
            // Invocations to non-mocked types are also allowed anywhere inside this block.
         }
      };

      // Unit under test is exercised.

      // Verification code, if any.
   }

   @Test
   public void test2(mock parameters)
   {
      // Preparation code not specific to JMockit, if any.

      // Unit under test is exercised.

      <strong>new Verifications()</strong> // a "verification block"
      {
         {
            // One or more invocations to mocked types, causing expectations to be verified.
         }
      };

      // Additional verification code, if any, either here or before the verification block.
   }

   @Test
   public void test3(mock parameters)
   {
      // Preparation code not specific to JMockit, if any.

      <strong>new NonStrictExpectations()</strong> // also an expectation block
      {
         // Zero or more mock fields.

         {
            // One or more invocations to mocked types, causing expectations to be recorded.
            // Invocations to non-mocked types are also allowed anywhere inside this block.
         }
      };

      // Unit under test is exercised.

      <strong>new VerificationsInOrder()</strong> // also a verifications block
      {
         {
            // One or more invocations to mocked types, causing expectations to be verified.
         }
      };

      // Additional verification code, if any, either here or before the verification block.
   }
}
</code></pre>
<p>
   There are other variations to the above templates, but the essence is that the expectation blocks belong to the
   <em>record</em> phase and come before the unit under test is exercised, while the verification blocks belong to the
   <em>verify</em> phase.
   A test method can contain any number of expectation blocks, including none. The same is true for verification blocks.
</p>
<p>
   The fact that anonymous inner classes are used to demarcate blocks of code allows us to take advantage of the
   "code folding" feature available in modern Java IDEs. The following image shows what it looks like in IntelliJ IDEA.
</p>
<img src="folding.PNG">

<h3 id="declaration">
   Declaring and using mocked types
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#model"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#results"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   A mocked type can be introduced either through an instance field or a parameter declaration.
   In the first case, the field belongs to the test class or to a <code class="type">mockit.Expectations</code>
   subclass (a local field inside an expectation block).
   In the second case, the parameter belongs to a test method.
</p>
<p>
   In all cases, a mock field/parameter declaration can use the <code class="type">mockit.Mocked</code> annotation.
   The use of this annotation is optional for mock parameters and for mock fields declared inside expectation blocks.
   It's only required for mock fields declared in the test class, in order to avoid confusion with other fields the test
   class might have that are not intended for mocking.
</p>
<p>
   All kinds of Java types are valid for mock fields and parameters, except for primitive types and for array types.
   So, to make it clear, the following reference types are valid: interfaces, concrete classes, <code>abstract</code>
   classes, <code>final</code> classes, <code>enum</code> types, and annotation types.
   Note that this includes reference types from the JRE (belonging to one of the standard packages, like
   <code>java.lang</code>, <code>java.util</code>, and so on).
</p>
<p>
   For a mock parameter, an instance of the declared type will be automatically created by JMockit and passed in the
   call to the test method. It will never be <code>null</code>.
</p>
<p>
   For a mock field, an instance of the declared type will be automatically created by JMockit and assigned to the
   field, unless it's a <code>final</code> field.
   In this case, a value should be assigned to the field explicitly in test code. Such a value can be <code>null</code>,
   though, which is perfectly valid for a mocked class if only constructors and static methods are going to be called on
   it.
</p>
<p>
   The mocked instances created by JMockit can be used normally in test code, and/or passed to the code under test.
   Differently from other mocking APIs, though, these <em>mocked</em> objects don't have to be the ones used by the unit
   under test when it calls instance methods on its dependencies.
   By default, JMockit does not care on which object a mocked instance method is called.
   This is what allows the transparent mocking of instances created directly inside code under test through invocations
   to constructors using the <code>new</code> operator.
   The classes instantiated must be covered by mocked types declared in test code, that's all.
</p>
<p>
   Finally, note that the <em>mocked instances</em> created by JMockit are similar to the traditional
   <em>mock objects</em> created by other mocking tools, but they are not the same.
   With the JMockit Expectations API, every instance of a mocked type - whether created by JMockit or not - is mocked,
   for as long as that type remains mocked.
   With a more traditional mocking API, only the mock objects/instances created by the mocking tool are actually mocked.
   Most of the time, this makes little or no difference when writing tests, but it is something to keep in mind. 
</p>

<h4 id="multipleInterfaces">Mocking multiple interfaces at the same time</h4>
<p>
   Suppose the unit under test needs to be given an object which implements two or more interfaces.
   Can we get a mocked instance which satisfies this requirement?
   One way to do it would be to create a test-specific interface which extends all the interfaces required by the tested
   unit, and then use that as the mocked type.
   There is a better way though, which does not require the definition of a new interface, as the following example
   tests show.
</p>
<pre><code>interface Dependency // an arbitrary custom interface
{
   String doSomething(boolean b);
}

public final class MultiMocksTest<strong>&lt;MultiMock extends Dependency & Runnable></strong>
{
   @Mocked <strong>MultiMock multiMock</strong>;

   @Test
   public void mockFieldWithTwoInterfaces()
   {
      new NonStrictExpectations()
      {
         {
            multiMock.doSomething(false); returns("test");
         }
      };

      multiMock.run();
      assertEquals("test", multiMock.doSomething(false));

      new Verifications()
      {
         {
            multiMock.run();
         }
      };
   }

   @Test
   public <strong>&lt;M extends Dependency & Serializable></strong> void mockParameterWithTwoInterfaces(final <strong>M mock</strong>)
   {
      new Expectations()
      {
         {
            mock.doSomething(true); returns("");
         }
      };

      assertEquals("", mock.doSomething(true));
   }
}
</code></pre>
<p>
   In each of the tests above, two interfaces were mocked together: <code class="type">Dependency</code> plus
   <code class="type">java.lang.Runnable</code> for a mock field, and <code class="type">Dependency</code> plus
   <code class="type">java.io.Serializable</code> for a mock parameter.
   We used the <em>type variables</em> <strong><code>MultiMock</code></strong> (defined for the whole test class) and
   <strong><code>M</code></strong> (defined for a single test method) so that JMockit could know about the component
   interfaces in each case.
</p>

<h3 id="results">
   Recording results for an expectation
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#declaration"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#onInstance"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   For a given method with non-<code>void</code> return type, a return value can be recorded through the
   <code>Expectations#result</code> field or through the <code>Expectations#returns(...)</code> method.
   When the method gets called in the replay phase, the specified return value will be returned to the caller (which
   normally is the unit under test).
</p>
<p>
   If the test instead needs an exception or error to be thrown when the method is invoked, then the <code>result</code>
   field can also be used to record the desired exception/error to be thrown, by having the desired throwable instance
   assigned to it.
   In the rare case where a method actually returns exception or error objects, the <code>returns(Object)</code> method
   will have to be used, to avoid the ambiguity.
   Note that recording exceptions/errors to be thrown is applicable to mocked methods as well as to mocked constructors.
</p>
<p>
   Multiple consecutive results (values to return and/or throwables to throw) can be recorded for the same expectation,
   by simply assigning the <code>result</code> field multiple times after the mock invocation that creates the
   expectation.
   The recording of multiple return values and/or exceptions/errors to be thrown can be freely mixed for the same
   expectation.
   In the case of recording multiple consecutive return values for a given expectation, a single call to the
   <code>returns(Object, Object...)</code> method can be made to specify more than one return value.
   The <code>result</code> field can also be used, by assigning it a list or array of the consecutive values.
   For more details about this ability, see the corresponding
   <a href="../javadoc/mockit/Expectations.html#returns(java.lang.Object, java.lang.Object...)">API documentation</a>.
</p>
<p>
   The following example test records expectations for two methods defined in a mocked class.
   The first one specifies that the unit under test should first invoke <code>intReturningMethod()</code> on an instance
   (any instance) of the mocked class, which will then return the value <code>5</code>.
   The second one specifies that the unit under test should then invoke <code>stringReturningMethod()</code> three
   times, with the first two calls resulting in the return values of <code>"str1"</code> and <code>"str2"</code>, and
   the third call causing an <code class="type">IllegalStateException</code> instance to be thrown.
</p>
<pre><code>   @Test
   public void someTestMethod()
   {
      new Expectations()
      {
         final DependencyAbc abc = new DependencyAbc();

         {
            abc.intReturningMethod(); <strong><em>result</em> = 5;</strong>

            abc.stringReturningMethod(); <strong>returns("str1", "str2");</strong>
            <em>result</em> = new IllegalStateException();
         }
      };

      new UnitUnderTest().doSomething();
   }
</code></pre>
<p>
   The example above actually contains three different expectations.
   The call to the <code>DependencyAbc()</code> constructor in the mock field assignment turns out to also be a mock
   invocation inside the expectation block, and as such it also defines an expectation.
   In fact, there was no need to call the constructor in the field assignment.
   Moving <code>new DependencyAbc();</code> to the beginning of the instance initialization block and leaving the mock
   field unassigned would have worked just as well.
   Often, however, it's not desirable or important to specify all these method and constructor invocations in a given
   test. We will soon address this issue.
</p>

<h4 id="defaultResults">Specifying default results</h4>
<p>
   Whenever an invocation to a mocked non-<code>void</code> method fails to match any recorded expectation, a default
   return value needs to be provided.
   JMockit will always supply a reasonable return value, according to the declared return type of the method:
   <code>0</code> (zero) for an integral primitive type, <code>false</code> for <code>boolean</code>, an empty
   collection or array, or the <code>null</code> reference for reference types (including <code>String</code> and the
   primitive wrapper classes).
   Mocked constructors and <code>void</code> methods also have a "default result", which is to simply return without
   throwing any exception or error.
   (Note, however, that when an invocation is deemed to be <em>unexpected</em>, an <code>AssertionError</code> is
   thrown instead of returning a value.)
</p>
<p>
   It's possible to explicitly override such default results in an expectation block, by declaring <em>input
   fields</em>. Such (instance) fields must be annotated with <code>@Input</code>. Here is an example.
</p>
<pre><code>   @Test
   public void someTestMethod()
   {
      new NonStrictExpectations()
      {
         DependencyAbc mock; // a mock field, assigned automatically

         // The <strong>names</strong> of input fields are merely for documentation.
         <strong>@Input</strong> final int defaultIntReturn = 5;
         <strong>@Input</strong> Socket aSocket;
         <strong>@Input</strong> FileNotFoundException onFileOpen;

         {
            abc.stringReturningMethod(); returns("str1", "str2");
         }
      };

      new UnitUnderTest().doSomething();
   }
</code></pre>
<p>
   In the case of return values, the declared type of the field must be the same as the return type of interest; any
   non-<code>void</code> methods having this return type will return the value assigned to the input field,
   <em>each</em> time they get invoked by the code under test, provided they are allowed to occur and there is no
   matching recorded expectation.
   In the example above, any method belonging to <code>DependencyAbc</code> which returns an <code>int</code> will
   return the value <code>5</code>; any method returning a <code>Socket</code> will return a socket object instantiated
   automatically with the <code>java.net.Socket</code> public no-args constructor (if a custom instance was needed, we
   could have it explicitly instantiated and assigned to the field).
</p>
<p>
   Methods or constructors that declare to throw <em>checked</em> exceptions can have one such exception specified as
   the default result, by simply declaring an input field of the desired exception type. An exception instance can be
   directly instantiated and assigned to the field; if none is, then JMockit will do so automatically using the public
   no-args constructor of the exception class.
   In the example test, if <code>DependencyAbc</code> has a method or constructor with
   <code>java.io.FileNotFoundException</code> in its <code>throws</code> clause, it will cause this exception to be
   thrown whenever a non-recorded invocation occurs during the test.
</p>
<p>
   Note that this mechanism depends only on <em>return types</em> or <em>throws clauses</em>, not on method names or
   parameters, or even on which mocked class or instance an invocation occurs.
   For many methods in production code, we often find that <em>only one</em> value of a certain type is needed for a
   given test of the method (particularly when it's a <em>reference</em> type, less so when it's a primitive or
   <code>String</code>).
   This property allows us to write a shorter test, where a "mere" default result is specified instead of having to
   record an expectation and deal with full method/constructor signatures.
   When more precision is required for a given test, a suitable expectation will have to be recorded, naturally.
</p>

<h3 id="onInstance">
   Matching invocations to specific instances
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#results"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#hamcrest"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   On the previous section we mentioned that a recorded invocation like <code>abc.intReturningMethod();</code> would
   actually match invocations to <code>DependencyAbc#intReturningMethod()</code> on <em>any</em> instance of the mocked
   <code>DependencyAbc</code> class.
   In most cases, this won't really matter and can be safely ignored.
   But what if we need to verify that the invocation occurs on a specific instance?
   We use the <code>Expectations#onInstance(mockObject)</code> method when recording the invocation,
   as the next example shows.
</p>
<pre><code>   @Test
   public void matchOnMockInstance(final Collaborator <strong>mock</strong>)
   {
      new Expectations()
      {
         {
            <strong>onInstance(mock)</strong>.getValue(); <em>result</em> = 12;
         }
      };

      // Exercise unit under test with the mocked instance passed from the test:
      int result = <strong>mock</strong>.getValue();

      assertEquals(12, result);
   }
</code></pre>
<p>
   The test above will only pass if the unit under test invokes <code>getValue()</code> on the exact
   same mock instance on which the recording invocation was made.
   This is typically useful when the unit under test makes calls on two or more different instances
   of the same type, and the test wants to verify that each invocation occurred on the proper instance.
   In fact, whenever two or more mocks of the exact same type are in scope for a given test, JMockit
   will automatically apply "onInstance" matching to all invocations made on those mocks.
   Therefore, in such common situations it isn't necessary to explicitly use the <code>onInstance(mock)</code> method.
</p>
<p>
   In practice, this matching specifier method will rarely be used.
   For a real-world example of this functionality, see the <code>CompositeEffectTest#testInit</code>
   test from the <em>Timing Framework</em> sample test suite.
</p>

<h3 id="hamcrest">
   Constraint-based matching of argument values
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#onInstance"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#constraints"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   In both the <em>record</em> and <em>verify</em> phases, an invocation to a mocked method or
   constructor identifies an expectation.
   If the method/constructor has one or more parameters, then a recorded/verified invocation like
   <code>doSomething(1, "s", true);</code> will only match an invocation in the <em>replay</em>
   phase if it has identical argument values.
</p>
<p>
   In a given test, we often don't know exactly what those argument values will be, or they simply
   aren't essential for what is being tested.
   So, to allow a recorded or verified invocation to match a whole set of replayed invocations with
   different argument values, we can specify flexible <em>argument matching constraints</em> instead
   of equal argument values.
   This is done through a set of <code>withXyz(...)</code> methods of the
   <code class="type">mockit.Invocations</code> base class (which both <code class="type">mockit.Expectations</code> and
   <code class="type">mockit.Verifications</code> extend), where "Xyz" describes the specific matching constraint.
   See examples below.
</p>
<pre><code>   @Test
   public void someTestMethod(@NonStrict final DependencyAbc abc)
   {
      final DataItem item = new DataItem(...);

      new Expectations()
      {
         {
            // Will match "new DependencyAbc(int)" invocations with any int-valued argument.
            new DependencyAbc(<strong>withAny(0)</strong>);

            // Will match "voidMethod(String, List)" invocations with the first argument
            // equal to "str" and the second not null.
            abc.voidMethod(<strong>"str", (List&lt;?>) withNotNull()</strong>);

            // Will match invocations to DependencyAbc#stringReturningMethod(DataItem, String)
            // with the first argument pointing to "item" and the second one containing "xyz".
            abc.stringReturningMethod(<strong>withSameInstance(item), withSubstring("xyz")</strong>);
         }
      };

      new UnitUnderTest().doSomething(item);

      new Verifications()
      {
         {
            // Matches invocations to the specified method with any long-valued argument.
            abc.anotherVoidMethod(<strong>(long) withAny()</strong>);
         }
      };
   }
</code></pre>
<p>
   There are more "with" methods than shown above.
   See the <a href="../javadoc/mockit/Expectations.html#withEqual(T)">API documentation</a> for more details.
</p>
<p>
   Besides the several predefined argument matching constraints available in the API, JMockit allows the user to provide
   custom constraints, through the <code>&lt;T> T with(Object)</code> and <code>&lt;T> T with(T, Object>)</code> generic
   methods.
   The parameter of type <code class="type">Object</code> can be an <code class="type">org.hamcrest.Matcher</code>
   object from the <a href="http://code.google.com/p/hamcrest">Hamcrest</a> library, or a suitable handler object
   (see the <a href="../javadoc/mockit/Expectations.html#with(T, java.lang.Object)">API documentation</a> for details).
</p>

<h4 id="matcherFields">Using the "any" <em>fields</em> for argument matching</h4>
<p>
   For the <code>withAny(?)</code> methods that take no arguments or take one only to designate
   the parameter type, there is a set of special <em>argument matching fields</em> that are
   available to expectation and verification blocks.
   Using these "any" fields will have the same effect as using the corresponding "withAny" method, as demonstrated
   below.
</p>
<pre><code>   @Test
   public void someTestMethod(@NonStrict final DependencyAbc abc)
   {
      final DataItem item = new DataItem(...);

      new Expectations()
      {
         {
            // Will match "new DependencyAbc(int)" invocations with any int-valued argument.
            new DependencyAbc(<strong><em>anyInt</em></strong>);

            // Will match "voidMethod(String, List)" invocations where the first argument is
            // "str" but the second can be anything.
            abc.voidMethod(<strong>"str", (List&lt;?>) <em>any</em></strong>);
         }
      };

      new UnitUnderTest().doSomething(item);

      new Verifications()
      {
         {
            // Matches invocations to the specified method with any long-valued argument.
            abc.anotherVoidMethod(<strong><em>anyLong</em></strong>);
         }
      };
   }
</code></pre>
<p>
   Again, see the <a href="../javadoc/mockit/Expectations.html#anyInt">API documentation</a> for
   more details on argument matching fields.
</p>

<h4 id="nullAsMatcher">Using the <code>null</code> value to match any object reference</h4>
<p>
   When using at least one argument matching method or field for a given expectation, we can specify
   that any object reference be accepted for a parameter of reference type by simply passing the
   <code>null</code> value instead of a <code>withAny()</code> or <code>any</code> argument matcher.
   In particular, this avoids the need to cast the value to the declared parameter type.
   However, bear in mind that this behavior is only applicable when <em>at least one</em> explicit
   argument matcher (either a "with" method or an "any" field) is used for the expectation.
   When passed in an invocation that uses no matchers, the <code>null</code> value will match only
   the <code>null</code> reference.
</p>
<p>
   In the previous test, we could therefore have written:
</p>
<pre><code>   @Test
   public void someTestMethod(@NonStrict final DependencyAbc abc)
   {
      ...

      new Expectations()
      {
         {
            ...
            abc.voidMethod(<strong>withEqual("str"), null</strong>);
         }
      };

      ...
   }
</code></pre>
<p>
   When one or more explicit matchers are present and the <code>null</code> reference must be
   matched for a given parameter, the <code>withNull()</code> method should be used.
</p>
<p>
   In conclusion, there are two <em>modes</em> for argument matching: the basic one where no
   matching constraints are specified and all arguments must be equal, and the one where matching
   constraints are specified for some or all parameters.
   The meaning of the <code>null</code> value is different for each mode, which may lead to confusion at times.
   For complex invocations where multiple arguments are involved, though, the benefits of being able
   to use "any" fields and the <code>null</code> reference should outweigh the additional API complexity.
</p>

<h4 id="varargs">Matching values passed through a <em>varargs</em> parameter</h4>
<p>
   <del>to be written</del>
</p>

<h3 id="constraints">
   Specifying invocation count constraints
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#hamcrest"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#strictness"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   So far, we saw that besides an associated method or constructor, an expectation can have a list
   of invocation results (a mix of return values for non-void methods, and/or thrown
   exceptions/errors) and also an argument matcher for each method/constructor parameter.
   Given that the unit under test can call the same method or constructor multiple times, with
   different or identical arguments, we need a way to account for all those separate invocations.
   One way, as already seen, is to simply record one separate invocation for each expected
   invocation; another is to record two or more expected results (each either a return value or a
   thrown exception/error) following a single mock invocation.
</p>
<p>
   Yet another way, particularly useful for <code>void</code> methods or when the test doesn't care
   about specific return values, is to specify an <em>invocation count constraint</em> for a given expectation.
   The API has several fields just for that: <code>times</code>, <code>minTimes</code>, and <code>maxTimes</code>.
   These fields belong to the <code class="type">mockit.Invocations</code> class, the non-public base class for
   both <code class="type">mockit.Expectations</code> and <code class="type">mockit.Verifications</code>.
   Therefore, an invocation count constraint can be specified either when recording or when verifying invocations.
   In either case, the method or constructor associated with the expectation will be constrained to
   have a number of invocations made by the unit under test that falls in the specified range.
   Any invocations less or more than the expected lower or upper limit, respectively, and the test
   execution will automatically fail.
</p>
<pre><code>   @Test
   public void someTestMethod(final DependencyAbc abc)
   {
      new Expectations()
      {
         {
            // By default, one invocation is expected, ie "times = 1;":
            new DependencyAbc();

            // At least two invocations are expected:
            abc.voidMethod(); <strong><em>minTimes</em> = 2;</strong>

            // 1 to 5 invocations are expected:
            abc.stringReturningMethod(); <strong><em>minTimes</em> = 1; <em>maxTimes</em> = 5;</strong>
         }
      };

      new UnitUnderTest().doSomething();
   }

   @Test
   public void someOtherTestMethod(final DependencyAbc abc)
   {
      new UnitUnderTest().doSomething();

      new Verifications()
      {
         {
            // Verifies that zero or one invocations occurred, with the specified argument value:
            abc.anotherVoidMethod(3); <strong><em>maxTimes</em> = 1;</strong>

            // Verifies the occurrence of at least one invocation with the specified arguments:
            DependencyAbc.someStaticMethod("test", false); // "minTimes = 1" is implied
         }
      };
   }
</code></pre>

<h3 id="strictness">
   <em>Strict</em> and <em>non-strict</em> expectations
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#constraints"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#verification"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Expectations recorded inside a <code>new Expectations() {...}</code> block are all
   <em>strict</em> by default, meaning that the invocations they specify are <em>expected</em> to
   occur during the <em>replay</em> phase, and in the same order as they were recorded.
   Even more, only these explicitly recorded expected invocations will be allowed to occur.
   Any <em>unexpected</em> invocations that were not recorded will automatically cause the test to fail.
</p>
<p>
   The <code class="type">mockit.NonStrictExpectations</code> class (which extends
   <code class="type">mockit.Expectations</code>), as the name indicates, is used when we want to record
   <em>non-strict</em> (or <em>loose</em>) expectations.
   Inside such a block, all invocations to mocked types will be <em>allowed</em> to occur during the
   replay phase, not <em>expected</em>. That is, by default they may or may not occur during replay.
   In addition, they don't have to occur in the same order as they were recorded.
</p>
<p>
   By default, an invocation recorded as an strict expectation will be expected to match exactly one
   invocation in the replay phase. That is, the expectation will have an invocation count constraint
   of <code>1</code>, as if it was followed by <code><em>times</em> = 1</code> assignment.
   An invocation recorded as non-strict, on the other hand, will by default be allowed to match any
   number of invocations in the replay phase. That is, its invocation count constraint will have a
   lower limit of <code>0</code> and an unbounded upper limit, as if followed by a <code>minTimes = 0</code> assignment.
   In either case, however, the default invocation count constraint can be overridden by an explicit
   one (that is, an explicit assignment to one of the <code>times/minTimes/maxTimes</code> fields).
</p>
<p>
   Notice that in the case of strict expectations, all the invocations occurring in the replay phase
   which match a recorded strict expectation are implicitly verified.
   The remaining invocations will be considered unexpected (and fail the test), unless the
   associated mocked type is not strict.
   So, the use of strict expectations which are verified implicitly precludes the use of
   verification blocks, which are used for explicit verification of invocations.
   In fact, inside a <code>new Verifications() {...}</code> block only invocations matching
   recorded non-strict expectations are permitted, as well as invocations to non-strict mocked types
   for which no expectation was explicitly recorded.
</p>
<p>
   To allow mixing strict and non-strict expectations inside an strict expectation block, we can
   apply the <code class="type">mockit.NonStrict</code> annotation to a mock field or parameter.
   Any invocation to such a mocked type will be considered as belonging to a non-strict expectation,
   and all unrecorded invocations in the replay phase will be allowed (that is, they will never be
   considered as unexpected, and therefore will not cause the test to fail).
   This is particularly useful to avoid the need to record invocations to constructors, or to any
   uninteresting methods.
</p>
<p>
   Inside an strict expectation block, an individual invocation can be explicitly marked as
   non-strict through a <code>notStrict()</code> call following the invocation.
   Most of the time, it will be easier to use a non-strict expectation block or a mock
   field/parameter annotated as non-strict, though.
</p>
<p>
   So, how do we choose between strict and non-strict expectations for a given test?
   There is really no general-purpose answer to this question. It will depend on the particulars of
   the unit under test, and on personal preferences. Also, keep in mind that a test can mix both
   kinds of expectations, so there is a lot of flexibility in using them.
</p>

<h4 id="strictMocks">Strict and non-strict <em>mocks</em></h4>
<p>
   It's usually best to think about <em>strictness</em> at the level of individual expectations, not
   at the level of mocked instances or types.
   That said, it is also correct to say that a given mocked instance (or mocked type) is strict or non-strict.
   All it means, really, is that all expectations associated to that particular instance/type have the same strictness.
   On the other hand, it's perfectly valid to record both strict and non-strict expectations for
   the same mocked instance or type, in the same test.
   And when using mock fields declared at the test class level, it's possible that a given mocked
   instance will be entirely strict in one test and entirely non-strict in another, in the same test class.
</p>
<p>
   The JMockit Expectations API lets you specify that a given recorded expectation should be
   non-strict (through the <code>notStrict()</code> method), that all expectations for a particular
   mock should be non-strict (by annotating the mock field or parameter with
   <code class="annotation">@NonStrict</code>), and that all expectations recorded inside a particular block should be
   non-strict (by extending the <code class="type">NonStrictExpectations</code> base class).
   That's it. There is no way to specify that a given expectation, a mock, or a whole expectation block should be
   <em>strict</em>.
</p>
<p>
   Strict expectations are recorded and verified <em>by default</em>, when we do <em>not</em>
   specify that they should be non-strict. For an expectation to be strict, it needs to be recorded
   inside an expectation block not derived from <code class="type">NonStrictExpectations</code>, for a mocked
   type not annotated as <code class="annotation">@NonStrict</code>.
</p>
<p>
   Remember that <em>unexpected invocations</em> can only be detected for so-called <em>strict mocks</em>, or for
   expectations with an specified maximum invocation count constraint.
   So, how do we obtain a mocked instance/type where all unrecorded expectations are considered to
   be strict (and therefore cause matching invocations at replay time to throw an "unexpected
   invocation" error)? Simple: by recording at least one <em>strict</em> expectation on the mocked
   instance/type. Note that this rules out the use of empty expectation blocks.
   If you need to specify that no invocations are allowed on a given mock, then either record a
   strict expectation with a <code>times = 0</code> constraint or use a
   <code>FullVerifications</code> block (explained in the next section).
</p>

<h4 id="iteratedExpectations">Iterated expectations</h4>
<p>
   When a sequence of consecutive invocations is recorded with strict expectations (the relative
   order between invocations is irrelevant with <em>non-strict</em> expectations), the whole
   sequence is expected to occur exactly once during the replay phase.
   Consider, however, the case where the tested code executes those invocations in a loop (or any kind of iteration).
   Assuming that the number of iterations is known in the test, we can still record those
   expectations with a single invocation to each method/constructor called inside the loop (that is,
   without writing a loop or repeating the expectations inside the expectation block).
   The next test demonstrates this feature, using the <code>Expectations(int numberOfIterations)</code> constructor.
</p>
<pre><code>   @Test
   public void recordStrictInvocationsInIteratingBlock(final Collaborator mock)
   {
      new <strong>Expectations(2)</strong>
      {{
         mock.setSomething(<em>anyInt</em>);
         mock.save();
      }};

      // In the tested code:
      mock.setSomething(123);
      mock.save();
      mock.setSomething(45);
      mock.save();
   }
</code></pre>
<p>
   The ability to specify how many iterations are expected for a group of invocations is typically
   used with strict expectations, but it also applies to non-strict expectations.
   There is also a <code>NonStrictExpectations(int numberOfIterations)</code> constructor.
</p>

<h3 id="verification">
   Explicit verification
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#strictness"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#delegates"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Strict expectations are verified implicitly, so there is no point in re-verifying them in a
   explicit verification block.
   Non-strict expectations, on the other hand, are usually verified through explicit invocations to
   mocked types in a verification block.
   As will be seen later, a recorded non-strict expectation can still be verified implicitly,
   without the need to write an invocation inside a verification block.
</p>
<p>
   Inside a <code>new Verifications() {...}</code> block we can use the same API that's available in
   a <code>new NonStrictExpectations() {...}</code> block, with the exception of the methods and
   fields used to record return values and thrown exceptions/errors.
   That is, all of the <code>withXyz(...)</code> argument matching methods can be used, as well as
   the <code>times</code>, <code>minTimes</code>, and <code>maxTimes</code> invocation count constraint fields.
</p>

<h4 id="importingMocks">Importing mocks from expectation blocks</h4>
<p>
   Mocked instances and mocked types declared as mock fields of the test class or as mock parameters
   of the test method are immediately available inside verification blocks.
   However, expectation blocks can also declare <em>local</em> mock fields, which won't be
   accessible outside the block.
   In such cases, it's possible to <em>import</em> those mocked instances into a verification block,
   as the next example shows.
</p>
<pre><code>   @Test
   public void importLocalMockFromPreviousNonStrictExpectationsBlock()
   {
      new NonStrictExpectations()
      {
         <strong>Dependency mock;</strong>

         {
            mock.notifyBeforeSave(); result = true;
         }
      };

      // Inside tested code:
      Dependency dependency = new Dependency();
      dependency.editABunchMoreStuff();

      new Verifications()
      {
         <strong>Dependency mock;</strong>

         {
            mock.editABunchMoreStuff();
         }
      };
   }
</code></pre>
<p>
   The mocked types to be imported are identified by the <em>types</em> of the fields declared in the verification,
   not by the field names. Typically, though, the same field names will be used to avoid confusion.
   This ability can be useful if for whatever reason mock parameters are not desired, or when
   capturing internally created instances of mocked types (explained in a later section).
</p>

<h4 id="neverHappened">Verifying that an invocation never happened</h4>
<p>
   To do this inside a verification block, add a <code>times = 0</code> assignment right after the
   invocation that is expected to not have happened during the replay phase.
   If one or more matching invocations did happen, the test will fail.
</p>

<h4 id="VerificationInOrder">Verification in order</h4>
<p>
   Regular verification blocks, like the one below, are <em>unordered</em>.
   The actual relative order in which <code>aMethod()</code> and <code>anotherMethod()</code> were
   called during the replay phase is not verified, but only that each method was executed at least once.
</p>
<pre><code>   @Test
   public void someTestMethod(final DependencyAbc abc)
   {
      ...

      new Verifications() // order of invocations does not matter
      {
         {
            <strong>abc.aMethod();
            abc.anotherMethod();</strong>
         }
      };
   }
</code></pre>
<p>
   If you do want to also verify the relative order of invocations, then a <code>new VerificationsInOrder() {...}</code>
   block must be used instead.
   Inside this block, simply write invocations to one or more mocked types in the order they are expected to have
   happened.
   Naturally, argument matchers and invocation count constraints can be freely used.
</p>

<h4 id="partiallyOrdered">Partially ordered verification</h4>
<p>
   Suppose you want to verify that a particular method (or constructor) was called <em>before</em>
   (or <em>after</em>) other invocations to mocked types in the replay phase, but you don't care
   about the order in which those other invocations occurred.
   Inside an ordered verification block (<code>VerificationsInOrder</code>), this can be achieved by simply calling the
   <a href="../javadoc/mockit/VerificationsInOrder.html#unverifiedInvocations()">unverifiedInvocations()</a>
   method at the appropriate place(s).
   The following test snippet demonstrates it.
</p>
<pre><code>   @Test
   public void someTestMethod(final DependencyAbc abc, final AnotherDependency xyz)
   {
      new UnitUnderTest().doSomething();

      <strong>new VerificationsInOrder()</strong>
      {
         {
            abc.methodThatNeedsToExecuteFirst();
            <strong>unverifiedInvocations();</strong> // Invocations not verified must come here...
            xyz.method1();
            abc.method2();
            <strong>unverifiedInvocations();</strong> // ... and/or here.
            xyz.methodThatNeedsToExecuteLast();
         }
      };
   }
</code></pre>
<p>
   The example above is actually quite sophisticated, as it verifies several things: a) a method
   that must be called <em>before</em> others; b) a method that must be called <em>after</em>
   others; and c) that <code>AnotherDependency#method1()</code> must be called just before
   <code>DependencyAbc#method2()</code>.
   In most tests, we will probably only do one of these different kinds of order-related
   verifications. But the power is there to make all kinds of complex verifications quite easily.
</p>
<p>
   Another situation not covered by the examples above is one where we want to verify that certain
   invocations occurred in a given relative order, while also verifying the other invocations
   (in a given order or in any order).
   For this, we need to write two separate verification blocks, as illustrated below (where
   <code>mock</code> is a mock field of the test class).
</p>
<pre><code>   @Test
   public void verifyFirstAndLastCallsWithOthersInBetweenInAnyOrder()
   {
      exerciseCodeUnderTest();

      <strong>new VerificationsInOrder()</strong>
      {{
         mock.prepare();
         <strong>unverifiedInvocations();</strong>
         mock.notifyBeforeSave();
         mock.save();
      }};

      <strong>new Verifications()</strong>
      {{
         mock.setSomething(123);
         mock.setSomethingElse("anotherValue");
      }};
   }
</code></pre>
<p>
   In the test above, the two invocations verified in the second block correspond to the
   "unverified invocations" from the first block.
   The relative order of the multiple verification blocks is actually irrelevant; each verification
   block is evaluated independently from the others.
</p>

<h4 id="FullVerification">Full verification</h4>
<p>
   Sometimes it may be important to have <em>all</em> invocations to the mocked types involved in a test verified.
   This is automatically the case when recording strict expectations, since any unexpected invocation causes the test to
   fail.
   When non-strict expectations are explicitly verified, though, a <code>new FullVerifications() {...}</code> block can
   be used to make sure that no invocations are left unverified.
</p>
<pre><code>   @Test
   public void verifyAllInvocations(final Dependency mock)
   {
      // Code under test included here for easy reference:
      mock.setSomething(123);
      mock.setSomethingElse("anotherValue");
      mock.setSomething(45);
      mock.save();

      <strong>new FullVerifications()</strong>
      {{
         // Verifications here are unordered, so the following invocations could be in any order.
         mock.setSomething(<em>anyInt</em>); // verifies two actual invocations
         mock.setSomethingElse(<em>anyString</em>);
         mock.save(); // if this verification (or any other above) is removed the test will fail
      }};
   }
</code></pre>
<p>
   Note that if a lower limit (a minimum invocation count constraint) is specified for an otherwise
   non-strict expectation, then this constraint will always be implicitly verified at the end of the test.
   Therefore, explicitly verifying such an expectation inside the full verification block is not necessary.
</p>

<h4 id="FullVerificationInOrder">Full verification in order</h4>
<p>
   So, we have seen how to do <em>unordered</em> verifications with <code>Verifications</code>,
   <em>ordered</em> verifications with <code>VerificationsInOrder</code>, and full verifications
   with <code>FullVerifications</code>.
   But what about <em>full ordered</em> verifications? Easy enough:
</p>
<pre><code>   @Test
   public void verifyAllInvocationsInOrder(final Dependency mock)
   {
      // Code under test included here for easy reference:
      mock.setSomething(123);
      mock.setSomethingElse("anotherValue");
      mock.setSomething(45);
      mock.save();

      <strong>new FullVerificationsInOrder()</strong>
      {{
         mock.setSomething(<em>anyInt</em>);
         mock.setSomethingElse(<em>anyString</em>);
         mock.setSomething(<em>anyInt</em>);
         mock.save();
      }};
   }
</code></pre>
<p>
   Notice there is a not so obvious difference in semantics, though.
   In the <code>verifyAllInvocations</code> test above, we were able to match two separate
   <code>mock.setSomething(...)</code> invocations with a single invocation in the verification block.
   In the <code>verifyAllInvocationsInOrder</code> test, however, we had to write two separate
   invocations to that method inside the block, in the proper order with respect to other invocations.
</p>
<p>
   You may now be thinking that writing a <code>FullVerificationsInOrder</code> block ends up being
   the same as writing an <code>Expectations</code> block where all expectations are strict.
   So, have we come full circle? Almost, but not quite.
   For non-strict expectations, the default invocation count constraint corresponds to a
   <code><em>minTimes</em> = 1</code> assignment, which leaves room for multiple invocations to the
   same method or constructor in the replay phase.
   So, in the above test for example, if the <code>setSomethingElse(...)</code> method was invoked
   a second time during the replay phase, the test would still pass (provided the second invocation
   occurred in the expected order, as specified inside the verification block).
</p>

<h4 id="restrictedFullVerifications">Restricting the set of mocked types to be fully verified</h4>
<p>
   By default, <em>all</em> invocations to <em>all</em> mocked instances/types in effect for a
   given test must be verified explicitly when using a <code>new FullVerifications() {}</code> or
   <code>new FullVerificationsInOrder() {}</code> block.
   Now, what if we have a test with two (or more) mocked types but we only want to fully verify
   invocations to one of them (or to any subset of mocked types when more than two)?
   The answer is to use the <strong><code>FullVerifications(Object... mockedTypesAndInstancesToVerify)</code></strong>
   constructor, where only the given mocked instances and mocked types (ie, class objects/literals) are considered.
   The following test provides an example.
</p>
<pre><code>   @Test
   public void verifyAllInvocationsToOnlyOneOfTwoMockedTypes(Dependency mock1, AnotherDependency mock2)
   {
      // Inside code under test:
      mock1.prepare();
      mock1.setSomething(123);
      <strong>mock2</strong>.doSomething();
      mock1.editABunchMoreStuff();
      mock1.save();

      new FullVerifications(mock1)
      {{
         mock1.prepare();
         mock1.setSomething(<em>anyInt</em>);
         mock1.editABunchMoreStuff();
         mock1.save(); <em>times</em> = 1;
      }};
   }
</code></pre>
<p>
   In the test above, the <code>mock2.doSomething()</code> invocation is never verified.
   It's possible to restrict verification only to the methods (and constructors) of a single class,
   by passing its class literal in the <code>FullVerifications(...)</code> or <code>FullVerificationsInOrder(...)</code>
   constructor.
   For example, the <code>new FullVerificationsInOrder(AnotherDependency.class) { ... }</code> block would only make
   sure that all invocations to the mocked <code class="type">AnotherDependency</code> class were verified.
</p>

<h4 id="emptyFullVerifications">Verifying that no invocations occurred</h4>
<p>
   To verify that <em>no</em> invocations at all occurred on the non-strict mocked types/instances used in a test, add
   an <em>empty</em> full verification block to it.
   As always, note that any expectations that were <em>recorded</em> as expected through an specified
   <code>times/minTimes</code> constraint are verified implicitly and therefore disregarded by the full verification
   block; in such a case the empty verification block will verify that no <em>other</em> invocations occurred.
   Additionally, if any expectations were verified in a <em>previous</em> verification block in the same test, they are
   also disregarded by the full verification block.
</p>
<p>
   If the test uses two or more mocked types/instances and you want to verify that no invocations occurred for some of
   them, specify the desired mocked types and/or instances in the constructor to the empty verification block.
   An example test follows.
</p>
<pre><code>   @Test
   public void verifyNoInvocationsOnOneOfTwoMockedDependenciesBeyondThoseRecordedAsExpected(
      final Dependency mock1, final AnotherDependency mock2)
   {
      new NonStrictExpectations()
      {{
         // These two are recorded as expected:
         mock1.setSomething(<em>anyInt</em>); <em>minTimes</em> = 1;
         mock2.doSomething(); <em>times</em> = 1;
      }};

      // Inside code under test:
      mock1.prepare();
      mock1.setSomething(1);
      mock1.setSomething(2);
      mock1.save();
      mock2.doSomething();

      // Will verify that no invocations other than to "doSomething()" occurred on mock2:
      <strong>new FullVerifications(mock2) {};</strong>
   }

</code></pre>

<h4 id="unspecifiedInvocations">Verifying unspecified invocations that should not happen</h4>
<p>
   A full verification block (ordered or not) also allows us to verify that certain methods and/or constructors never
   get invoked, without having to specify each one of them with a corresponding <code><em>times</em> = 0</code>
   assignment.
   The following test provides an example.
</p>
<pre><code>   @Test
   public void readOnlyOperation(final Dependency mock)
   {
      new NonStrictExpectations()
      {{
         mock.getData(); <em>result</em> = "test data";
      }};

      // Code under test:
      String data = mock.getData();
      // <strong>mock.save() should not be called here</strong>
      ...

      <strong>new FullVerifications()</strong>
      {{
         mock.getData(); <strong><em>minTimes</em> = 0; // calls to getData are allowed</strong>
      }};
   }
</code></pre>
<p>
   If a call to any method (or constructor) of the <code>Dependency</code> class occurs during the
   replay phase, except for the ones explicitly verified in the verification block
   (<code>Dependency#getData()</code> in this case), then the test above will fail.
   On the other hand, it may be easier to use strict expectations in such cases, without any verification block at all.
</p>

<h4 id="iterations">Verifying iterations</h4>
<p>
   There is one last thing about verification blocks we need to examine: the ability to easily
   verify invocations that occur inside loops, for an specified number of iterations of the loop.
</p>
<pre><code>   @Test
   public void verifyAllInvocations(final Dependency mock)
   {
      int numberOfIterations = 3;

      // Code under test included here for easy reference:
      for (int i = 0; i < numberOfIterations; i++) {
         DataItem data = getData(i);
         mock.setData(data);
         mock.save();
      }

      <strong>new Verifications(numberOfIterations)</strong>
      {{
         mock.setData((DataItem) withNotNull());
         mock.save();
      }};

      <strong>new VerificationsInOrder(numberOfIterations)</strong>
      {{
         mock.setData((DataItem) withNotNull());
         mock.save();
      }};
   }
</code></pre>
<p>
   The use of two verification blocks above is just to explain the different semantics between
   ordered and unordered iterating verification blocks.
   In the first block, each verified invocation will have to match at least three invocations to the
   same method in the replay phase, because this was the number of iterations passed in the constructor.
   For an unordered iterating block, the specified number of iterations is effectively multiplied by
   the lower and upper invocation count limits; this happens even if an explicit constraint is
   specified inside the block, such as a <code><em>minTimes</em> = 1; <em>maxTimes</em> = 4;</code>
   pair of assignments, which in this particular example would be turned into
   <code><em>minTimes</em> = 3; <em>maxTimes</em> = 12;</code>.
   In the second block, on the other hand, invocation count constraints are not affected.
   Instead, the resulting effect is equivalent to "unrolling the loop", as if the whole sequence of
   verified invocations inside the block was duplicated for each iteration.
</p>
<p>
   The semantics for an iterating <code>FullVerifications</code> block is the same as for a regular
   <code>Verifications</code> block.
   The same applies for an iterating <code>FullVerificationsInOrder</code> block, with respect to a
   <code>VerificationsInOrder</code> block.
</p>

<h3 id="delegates">
   Delegates: specifying custom results and capturing arguments
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#verification"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#forEachInvocation"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   We have seen how to record results for invocations through assignments to the
   <code><em>result</em></code> field or calls to the <code>returns(...)</code> methods.
   We have also seen how to match invocation arguments flexibly with the <code>withXyz(...)</code>
   group of methods and the various <code><em>anyXyz</em></code> fields.
   But what if a test needs to decide the result of a recorded invocation based on the arguments it
   will receive at replay time?
   We can do it through a <code class="type">mockit.Delegate</code> instance, as exemplified below.
</p>
<pre><code>   @Test
   public void someTestMethod()
   {
      new Expectations()
      {
         @NonStrict DependencyAbc abc;

         {
            abc.intReturningMethod(<em>anyInt</em>, null);
            <em>result</em> = <strong>new Delegate()
            {
               // The name of this method can actually be anything.
               int intReturningMethod(int i, String s)
               {
                  assertTrue(i > 0);
                  assertEqual(i == 1 ? "one" : "other", s);
                  return i + 1;
               }
            }</strong>;
         }
      };

      new UnitUnderTest().doSomething();
   }
</code></pre>
<p>
   The <code class="type">Delegate</code> interface is empty, being used simply to tell JMockit that actual
   invocations at replay time should be delegated to the corresponding methods in the delegate object.
</p>
<p>
   A corresponding method in the delegate implementation must have parameters matching the method
   in the mocked type for which an invocation is being recorded.
   The name of this delegate method can be different though, provided it is the <em>only one</em>
   defined in the delegate implementation class.
   If the class has two or more methods (with <em>any</em> modifiers), then one of them will have
   to match both the name and the parameters of the corresponding recorded method.
   Note that the return type of a delegate method does not have to be exactly the same, since it's
   not part of the method signature. It should be compatible, though, otherwise a
   <code class="type">ClassCastException</code> is likely.
   Note also that this can de done for non-<code>public</code> methods and even for
   <code>static</code>, <code>final</code>, and <code>native</code> mocked methods.
</p>
<p>
   The following example test shows a <em>constructor</em> invocation being delegated in a reusable
   <code class="type">Delegate</code> class, which saves an argument value for later verification in the test.
</p>
<pre><code>   @Test
   public void anotherTestMethod()
   {
      <strong>final ConstructorDelegate delegate = new ConstructorDelegate();</strong>

      new Expectations()
      {
         Collaborator mock;

         {
            new Collaborator(<em>anyInt</em>); <em>result</em> = <strong>delegate</strong>;
         }
      };

      new Collaborator(4);

      assertTrue(<strong>delegate.capturedArgument</strong> > 0);
   }

   <strong>static class ConstructorDelegate implements Delegate
   {
      int capturedArgument;

      void $init(int i) { capturedArgument = i; }
   }</strong>
</code></pre>
<p>
   Constructors are also handled by delegate <em>methods</em>, except that such methods must be named "$init".
</p>

<h3 id="forEachInvocation">
   Validating invocation arguments
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#delegates"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#deencapsulation"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   <code>Delegate</code> implementations can be used to validate invocation arguments, but they are limited to
   expectation blocks. Besides, the main point of delegate methods is to specify <em>invocation results</em> (values to
   return or exceptions to throw) at replay time, based on the arguments received.
   If the actual need is to validate the arguments passed at replay time in each invocation matching
   an expectation, the <strong><code>forEachInvocation</code></strong> field should be used instead.
   Such validations can be specified not only in expectation blocks, but also in verification blocks.
   For example, consider the following test:
</p>
<pre><code>   @Test
   public void verifyExpectationWithArgumentValidatorForEachInvocation(final Collaborator mock)
   {
      // Inside tested code:
      new Collaborator().doSomething(true, new int[2], "test");

      new Verifications()
      {
         {
            mock.doSomething(<em>anyBoolean</em>, null, null);
            <em>forEachInvocation</em> = new Object()
            {
               void validate(Boolean b, int[] i, String s)
               {
                  assertTrue(b);
                  assertEquals(2, i.length);
                  assertEquals("test", s);
               }
            };
         }
      };
   }
</code></pre>
<p>
   In this test, all invocations to the <code>Collaborator#doSomething</code> method that occur during the replay phase
   and that match the verified expectation will be validated by a call to the specified <code>validate</code> method.
   Each such call will be made with the same arguments that the verified method/constructor received at replay time.
   In this particular example, the verified expectation matches invocations with any arguments, but
   more strict argument matchers could have been specified.
</p>
<p>
   Differently from <code>Delegate</code> implementations, the object assigned to the <code>forEachInvocation</code>
   field can be of any type.
   The implementation class, however, should define exactly one non-<code>private</code> method of any name, with the
   same number of parameters as the validated method/constructor (any number of additional <code>private</code> methods
   is allowed).
   The types of corresponding parameters don't have to be exactly the same, but they must be 
   compatible in order to avoid the potential for <code class="type">ClassCastException</code>'s.
</p>
<p>
   Optionally, a first parameter of type <code class="type">mockit.Invocation</code> can be declared in the
   validation method, which should still have the remaining parameters. The semantics in this case
   are the same as in the case of a <code class="type">Delegate</code> method with that same special parameter.
</p>

<h3 id="deencapsulation">
   Accessing private fields, methods and constructors
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#forEachInvocation"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#partial"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Normally, behavior-based tests for a given unit are written against the
   <code>public/protected/default</code> interface of the unit's dependencies.
   Sometimes, however, the method being tested may call <code>private</code> methods defined in the
   same class, and accounting for the behavior of those methods in the test may be undesirable
   (perhaps because it is too complex or simply not important for the test).
</p>
<p>
   A different situation arises when a test wants to verify not only the behavior, but also the
   state of the unit under test after it is exercised, and the relevant state is stored in non-accessible fields.
   Some tests may also need to set some necessary state in non-accessible fields of the unit under test before it is
   exercised.
</p>
<p>
   A third kind of situation would be the eventual need to instantiate non-accessible classes from a
   given test. Such a need should be rare, though.
</p>
<p>
   To handle these needs (rare though they may be) the <code class="type">Expectations</code> class provides a
   set of Reflection-based utility methods that allow a test to invoke non-accessible methods on a
   given object or class, to instantiate objects through non-accessible constructors, and to get or
   set the values of fields in given objects or classes.
   The example test below showcases some of these utility methods.
</p>
<pre><code>   @Test
   public void someTestMethod()
   {
      final UnitUnderTest tested = new UnitUnderTest();

      new Expectations()
      {
         @NonStrict DependencyAbc abc;

         {
            // Defines some necessary state on the unit under test:
            <strong>setField(tested, "someIntField", 123);</strong>

            // Expectations recorded (even if the invocations are done through Reflection):
            <strong>newInstance("some.package.AnotherDependency", true, "test");</strong> <em>maxTimes</em> = 1;
            <strong>invoke(tested, "intReturningMethod", 45, "");</strong> <em>result</em> = 1;
            // other expectations recorded...
         }
      };

      tested.doSomething();

      String result = <strong>Deencapsulation.getField(tested, "result");</strong>
      assertEquals("expected result", result);
   }
</code></pre>
<p>
   The utility methods mentioned above are actually defined in the <code class="type">Invocations</code> base class,
   and therefore they are also available to <code class="type">Verifications</code> subclasses.
   This allows invocations to private methods and constructors to be verified in a verification block, just like they
   can be recorded in an expectation block.
</p>
<p>
   The <code class="type">mockit.Deencapsulation</code> class used at the end of the test is a separate utility
   class which contains those same Reflection-based utilities.
   It's a more generally useful class, since it can be called from any place in test code.
   Its methods are all <code>static</code>, so they can be statically imported for easier access.
</p>

<h3 id="partial">
   Partial mocking
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <a href="#reuse"><img align="right" src="go-bottom.png" title="Last section"></a>
      <a href="#deencapsulation"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#cascading"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   In a test class, we declare mocked types through mock fields and mock parameters, sometimes using one of the
   <code class="annotation">@Mocked</code> and <code class="annotation">@NonStrict</code> annotations, sometimes by
   simply letting JMockit infer from the declaration scope if the field or parameter is to be mocked or not.
   By default, in any such case <em>all</em> instance methods which can be called on the mock
   field/parameter, and <em>all</em> constructors and static methods which can be called on the
   mocked class and its super-classes (except for <code class="annotation">java.lang.Object</code>) will get mocked.
   That is, by default we get a fully mocked type, be it an interface or a class of any kind.
</p>
<p>
   Full mocking will be appropriate in most cases, but in some situations we might need to exclude
   some methods or constructors from being mocked. Alternatively, we might want to only mock a few
   specific methods/constructors. This is where <em>partial mocking</em> comes into the picture.
</p>
<p>
   If for a given test a type is partially mocked, then it won't be possible to record nor verify
   expectations for non-mocked methods/constructors. When one of these methods/constructors is
   invoked during any of the three test phases (particularly the <em>replay</em> phase), the actual
   method/constructor body will be executed.
</p>

<h4 id="staticPartial">Static partial mocking</h4>
<p>
   Methods and constructors to be mocked can be explicitly specified through the
   <code><span class="annotation">@Mocked</span>(<strong>methods</strong> = {"filter1", "filter2", ...})</code>
   annotation attribute.
   Each filter value is composed of an optional regular expression (<code>java.util.regex</code>)
   that matches method names, followed by an also optional parenthesized list of parameter type names.
   The following example test shows several ways to use partial mocking.
</p>
<pre><code>public class MyTestClass
{
   @Mocked(<strong>"nanoTime"</strong>) final System system = null;
   @Mocked(<strong>"print"</strong>) final JComponent component = new JButton();

   @Test
   public void staticPartialMocking(@Mocked(<strong>methods = "()", inverse = true</strong>) final Graphics graphics)
   {
      ...

      new Expectations()
      {
         @Mocked(<strong>{"(int)", "doInternal()", "[gs]etValue", "complexOperation(Object)"}</strong>)
         Collaborator mock;

         {
            graphics.setClip(0, 0, 80, 60);
            graphics.translate(-15, -12);
            component.print(graphics);

            mock.getValue();
         }
      };

      ...
   }
}
</code></pre>
<p>
   For convenience, the <code class="annotation">@Mocked</code> annotation defines the default <code>value</code>
   attribute as a synonym for the <code>methods</code> attribute.
   This is what allows us to write <code><span class="annotation">@Mocked</span>("nanoTime")</code>, as shown above.
</p>
<p>
   The <code>inverse</code> attribute, which by default is equal to <code>false</code>, inverts the
   meaning of the specified mock filters.
   For example, as <code><span class="annotation">@Mocked</span>("nanoTime")</code> or
   <code><span class="annotation">@Mocked</span>(methods = "nanoTime", inverse = false)</code> cause only the
   <code>System#nanoTime()</code> method to be mocked, the inverse specification
   <code><span class="annotation">@Mocked</span>(methods = "nanoTime", inverse = true)</code> cause it to be the only
   method <em>not</em> mocked in the <code class="type">java.lang.System</code> class.
</p>
<p>
   To specify constructors through a mock filter expression, leave the first part (which corresponds
   to method names) empty and specify the constructor parameter type names between parentheses.
   Use commas to separate parameters, if more than one.
   The parameter type name actually can be any unique suffix of the fully qualified type name.
   In practice, this means that it's almost never necessary to specify any package names for a reference type.
</p>
<p>
   Specifying parameter types in a filter expression that targets methods is possible, but usually
   unnecessary. It will only be required if the method is overloaded.
</p>
<p>
   Finally, notice that when the mocked type is a class, a mock filter expression for methods will
   actually match methods defined anywhere in the class hierarchy, from the mocked class up to
   <code class="type">Object</code> (not itself included).
</p>

<h4 id="dynamicPartial">Dynamic partial mocking</h4>
<p>
   Static partial mocking has the inconvenience that we need to explicitly specify the
   methods/constructors to be mocked or not mocked, and do so inside strings instead of in Java code.
   In short, it entails extra work and is not "refactoring friendly".
</p>
<p>
   An alternative that avoids both problems is to let JMockit figure out when to execute the real
   implementation of methods/constructors during the <em>replay</em> phase, based on which
   invocations were recorded in an expectation block and which were not.
   The following example tests demonstrate this feature, which we describe as <em>dynamic partial mocking</em> since
   the decision of what is mocked is made at runtime, as invocations to mocked types during the replay phase match
   invocations recorded in expectation blocks.
</p>
<pre><code>public final class DynamicPartialMockingTest
{
   static class Collaborator
   {
      private final int value;

      Collaborator() { value = -1; }
      Collaborator(int value) { this.value = value; }

      int getValue() { return value; }
      final boolean simpleOperation(int a, String b, Date c) { return true; }
      static void doSomething(boolean b, String s) { throw new IllegalStateException(); }
   }

   @Test
   public void dynamicallyMockAClass()
   {
      new Expectations(<strong>Collaborator.class</strong>)
      {{
         new Collaborator().getValue(); <em>result</em> = 123;
      }};

      // Mocked:
      Collaborator collaborator = new Collaborator();
      assertEquals(123, collaborator.getValue());

      // Not mocked:
      assertTrue(collaborator.simpleOperation(1, "b", null));
      assertEquals(45, new Collaborator(45).value);
   }

   @Test
   public void dynamicallyMockAnInstance()
   {
      final Collaborator collaborator = new Collaborator(2);

      new NonStrictExpectations(<strong>collaborator</strong>)
      {{
         collaborator.simpleOperation(1, "", null); <em>result</em> = false;
         Collaborator.doSomething(<em>anyBoolean</em>, "test");
      }};

      // Mocked:
      assertFalse(collaborator.simpleOperation(1, "", null));
      Collaborator.doSomething(true, null);

      // Not mocked:
      assertEquals(2, collaborator.getValue());
      assertEquals(45, new Collaborator(45).value);
      assertEquals(-1, new Collaborator().value);
   }
}
</code></pre>
<p>
   As shown above, the <code>Expectations(Object...)</code> and <code>NonStrictExpectations(Object...)</code>
   constructors accept one or more classes or objects to be partially mocked.
   If the <code>Class</code> object for a given class is passed, the methods and constructors
   defined in that class are considered for mocking, but <em>not</em> the methods and constructors
   of its super-class (and so on until <code>Object</code>).
   If an instance of a given class is passed, on the other hand, then all methods and constructors
   defined in the whole class hierarchy, from the concrete class of the given instance up to (but
   not including) <code>Object</code>, are considered for mocking.
</p>
<p>
   Notice that in these two example tests there is no mock field or mock parameter.
   This feature effectively provides yet another way to specify mocked types, which lets us turn
   objects stored in <em>local variables</em> into mocked instances.
   Such objects can be created with any amount of state in instance fields; they will keep that
   state after being mocked.
</p>
<p>
   With <em>regular</em> mocking, invocations to mocked types or mock instances that occur during
   replay time will never cause the real method/constructor implementation to be executed.
   With dynamic mocking, on the other hand, whether the real implementation gets executed or not
   depends on the existence of a recorded expectation that <em>matches</em> the invocation.
   If such a matching expectation exists, the invoked method or constructor is still mocked,
   preventing its real implementation to be executed. If no such expectation can be found for a
   particular invocation at replay time, the real implementation gets executed.
   This is a simple rule, but it can produce surprising results, specially when <em>strict</em>
   expectations are recorded on a dynamic mock. For example, if you record a strict expectation on
   a dynamically mocked object with a maximum invocation count of <em>n</em> (specified either
   through the <code>times</code> or <code>maxTimes</code> field), then only the first <em>n</em>
   invocations at replay time will match the expectation; the next invocation, if it occurs, will
   cause the real method implementation to be executed, instead of causing the test to fail with an
   "unexpected invocation" error.
</p>
<p>
   It's also possible to pass the objects automatically created for mock fields or parameters into
   those expectation block constructors.
   The declaration of such dynamically mocked mock fields/parameters can make use of the
   <code>Mocked</code> annotation and any of its attributes.
   We could even combine static and dynamic partial mocking for the same mocked class, although that
   wouldn't probably be of much use.
</p>
<p>
   Finally, dynamically mocked types can be freely verified inside <em>verification</em> blocks.
   Just like in expectation blocks, invocations to them will never execute the real implementation
   when inside the verification block.
</p>

<h3 id="cascading">
   Cascading mocks
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#partial"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#capturing"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   When using complex APIs where functionality is distributed through many different objects, it is not uncommon to see
   chained invocations of the form <code>obj1.getObj2(...).getYetAnotherObj().doSomething(...)</code>.
   In such cases it may be necessary to mock all objects/classes in the chain, starting with <code>obj1</code>.
</p>
<p>
   The <code class="annotation">@Cascading</code> annotation provides this ability.
   Just like <code class="annotation">@Mocked</code>, it can be applied to mock fields and mock parameters.
   Similarly to <code class="annotation">@NonStrict</code> and <code class="annotation">@Capturing</code>, the use of
   <code class="annotation">@Cascading</code> on a mock field or test method parameter will imply that the type is
   mocked (this doesn't preclude use of <code class="annotation">@Mocked</code> on the same field/parameter, however).
   The following test shows a basic example, where the cascading mocked type is used in expectation
   and verification blocks. The test involves use of the <code>java.net</code> and <code>java.nio</code> APIs.
</p>
<pre><code>   @Test
   public void recordAndVerifyExpectationsOnCascadedMocks(@Cascading final Socket mock)
      throws Exception
   {
      new NonStrictExpectations()
      {
         InetSocketAddress ignored;

         {
            mock.getChannel().isConnected(); <em>result</em> = false;
         }
      };

      // Inside production code:
      Socket s = new Socket(...);
      ...
   
      if (!s.getChannel().isConnected()) {
         SocketAddress sa = new InetSocketAddress("remoteHost", 123);
         s.getChannel().connect(sa);
      }

      ...
   
      new Verifications()
      {
         {
            mock.getChannel().connect((SocketAddress) withNotNull());
         }
      };
   }
</code></pre>
<p>
   In the test above, since the <code class="type">Socket</code> class was mocked with cascading, any calls to
   methods like <code>getChannel()</code> will return a <em>cascaded mock</em> object whenever they
   occur during the test. The cascaded mock will allow further cascading, so a <code>null</code>
   reference will never be obtained from methods which return object references (except for return
   types <code>Object</code> or <code>String</code> which will return <code>null</code>, or
   collection types which will return a non-mocked empty collection).
</p>
<p>
   By default, a new cascaded mock is created for each unique chain of method calls, starting from a
   given cascading type. If necessary, this default mock can be replaced with a regular mock,
   introduced though a mock field or parameter. To do so, assign the desired mock instance to the
   <code>result</code> field, right after the method invocation chain of interest.
</p>

<h3 id="capturing">
   Capturing internal instances of mocked types
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#cascading"><img align="right" src="go-up.png" title="Previous section"></a>
      <a href="#reuse"><img align="right" src="go-down.png" title="Next section"></a>
   </div>
</h3>
<p>
   Our discussion of this feature will be based on the (contrived) code below.
   Realistic examples can be found in the <em>Timing Framework</em> and <em>Animated 
   Transitions</em> sample test suites, available with the full JMockit distribution.
</p>
<pre><code>public interface Service
{
   int doSomething();
}

final class ServiceImpl implements Service
{
   public int doSomething() { return 1; }
}

public final class TestedUnit
{
   private final Service service1 = <strong>new ServiceImpl();</strong>
   private final Service service2 = <strong>new Service()
   {
      public int doSomething() { return 2; }
   };</strong>

   Observable observable;

   public int businessOperation(final boolean b)
   {
      <strong>new Callable()</strong> // Callable is a parameterized interface from java.util.concurrent
      {
         public Object call() { throw new IllegalStateException(); }
      }.call();

      observable = <strong>new Observable()</strong> // Observable is a concrete class from java.util
      {{
         if (b) {
            throw new IllegalArgumentException();
         }
      }};

      return service1.doSomething() + service2.doSomething();
   }
}
</code></pre>
<p>
   The method we want to test, <code>businessOperation(boolean)</code>, creates several new
   instances of classes that implement public abstractions.
   Most of these implementations are defined through anonymous inner classes, which are completely
   inaccessible (except for the use of Reflection) from client code.
</p>
<p>
   This kind of situation will probably not occur often in real projects, though.
   Still, we can write a test that <em>captures</em> such class definitions and instantiations as
   they happen during test execution, automatically mocking the implementation classes as they are
   loaded by the JVM.
   (As a matter of fact, classes that have been loaded previously will also get mocked for the
   duration of a given test, transparently and as needed.)
   The next test shows how it's done.
</p>
<pre><code>public final class UnitTest
{
   @Mocked(<strong>capture = 10</strong>) Service service;

   @Test
   public void captureAllInternallyCreatedInstances(@Mocked(<strong>capture = 1</strong>) final Callable&lt;?> callable)
      throws Exception
   {
      Service initialMockService = service;

      new NonStrictExpectations()
      {
         @Mocked(<strong>capture = 1</strong>) Observable observable;

         {
            service.doSomething(); returns(3, 4);
         }
      };

      TestedUnit unit = new TestedUnit();
      int result = unit.businessOperation(true);

      assertNotNull(unit.observable);
      assertNotSame(initialMockService, service);
      assertEquals(7, result);

      new Verifications() {{ <strong>callable.call();</strong> }};
   }
}
</code></pre>
<p>
   Note that we used all three possible scopes for mocked types: a mock field of the test class, a
   mock parameter of the test method, and a local mock field of the expectation block.
   In all three cases the mocked type is either an interface or a non-<code>final</code> class, and
   the <code>capturing</code> annotation attribute has been used.
</p>
<p>
   This optional attribute of the <code>Mocked</code> annotation takes an <code>int</code> value
   that specifies the maximum number of instantiations of classes assignable to the declared mocked
   type that should be captured.
   For a non-<code>final</code> mock field, each captured instance will be immediately assigned to
   the field, up to the specified maximum number of instances.
   If any more instantiations occur they won't be assigned to the field, even though the classes to
   which such instances belong will still get mocked.
   However, if there is a second capturing field of the same mocked type, then those extra instances
   will get assigned to it up to the <em>its</em> maximum number of instances to capture.
   So, once a mocked type is declared to be captured, all implementation classes will get mocked for
   the test, no matter how many new instances are captured.
   For a mock parameter, on the other hand, new instances will never get assigned to the parameter,
   so any positive value for the <code>capture</code> attribute will have the same effect (this
   limitation may be lifted in a future version, for non-<code>final</code> parameters).
</p>
<p>
   Finally, notice that it is perfectly valid to record and/or verify invocations to the captured
   mocked types, as exemplified in the expectation and verification blocks above.
</p>

<h3 id="reuse">
   Reusing expectation and verification blocks
   <div class="navigation">
      <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
      <a href="#mocked"><img align="right" src="go-top.png" title="First section"></a>
      <img align="right" src="blank.gif" width="22">
      <a href="#capturing"><img align="right" src="go-up.png" title="Previous section"></a>
      <img align="right" src="blank.gif" width="22">
   </div>
</h3>
<p>
   The simplest form of test code reuse with JMockit is the declaration of mock fields at the test
   class level.
   As the next example shows, the objects that are automatically created and assigned to such fields
   (when they aren't declared to be <code>final</code>, that is) can be used in any number of test
   methods.
   (The complete source code for this example can be found under "mockit/samples/LoginService", in
   the full distribution.)
</p>
<pre><code>public final class LoginServiceTest
{
   <strong>@Mocked UserAccount account;</strong>
   LoginService service;

   @Before
   public void init()
   {
      service = new LoginService();

      new NonStrictExpectations()
      {{
         UserAccount.find("john"); <em>result</em> = <strong>account</strong>;
      }};
   }

   @Test
   public void setAccountToLoggedInWhenPasswordMatches() throws Exception
   {
      <strong>willMatchPassword(true);</strong>

      service.login("john", "password");

      new Verifications()
      {{
         <strong>account</strong>.setLoggedIn(true);
      }};
   }

   private void willMatchPassword(final boolean match)
   {
      new NonStrictExpectations()
      {{
         <strong>account</strong>.passwordMatches(<em>anyString</em>); <em>result</em> = match;
      }};
   }

   @Test
   public void notSetAccountLoggedInIfPasswordDoesNotMatch() throws Exception
   {
      <strong>willMatchPassword(false);</strong>

      service.login("john", "password");

      new Verifications()
      {{
         <strong>account</strong>.setLoggedIn(true); <em>times</em> = 0;
      }};
   }

   // other tests that use the "account" mock field
}
</code></pre>
<p>
   In the above test class, we have two instance fields, one of them a mock field that is assigned
   automatically by JMockit for each test, and the other a regular non-mock field which is assigned
   manually in a test setup method.
</p>
<p>
   The tests in this example test class exercise the
   <code>LoginService#login(String accountId, String password)</code> method (our <em>unit under test</em>).
   This method first attempts to look up an existing user account from the given login name
   ("accountId", which is expected to be unique among all accounts).
   Since several different tests are needed to fully exercise this unit, a non-strict invocation to
   the <code>UserAccount#find(String accountId)</code> method is recorded for all tests in the
   class, with an specific login name ("john") and the mock account object as the value to be returned.
   Remember, any given test can use multiple expectation and/or verification blocks.
   And such blocks can even be written inside shared "before" and "after" methods, respectively.
</p>
<p>
   Since the object assigned to a mock field of the test class is available <em>anywhere</em> in the
   class, not just inside expectation/verification blocks, there is the question of just what
   happens as a consequence of such invocations, if any occur.
   The answer is that such invocations are freely <em>allowed</em>, and in the case of
   non-<code>void</code> methods the invocation will return the default value according to the
   method's return type (<code>0</code> for primitive integers, empty collections and arrays, and so on).
</p>
<p>
   Another form or reuse exemplified above is shown by the <code>willMatchPassword(boolean)</code>
   method, which contains another reusable expectation block.
   In this case, an invocation to the <code>UserAccount#passwordMatches(String)</code> method is
   recorded for any password value, with the resulting return value provided as a parameter to the reusable method.
</p>
<p>
   Yet another form of reuse for expectation and verification blocks is to create named subclasses instead of anonymous
   ones.
   For example, instead of having the <code>willMatchPassword(boolean)</code> method we could have a reusable inner
   class:
</p>
<pre><code>   <strong>final</strong> class PasswordMatching extends NonStrictExpectations
   {
      PasswordMatching(boolean match)
      {
         account.passwordMatches(<em>anyString</em>); <em>result</em> = match;
      }
   }

   @Test
   public void setAccountToLoggedInWhenPasswordMatches() throws Exception
   {
      <strong>new PasswordMatching(true);</strong>

      ...
   }
</code></pre>
<p>
   It's important that such classes be declared as <code>final</code>, unless they are intended
   to be used as base classes for further extension inside individual test methods.
   They can also be static nested classes and even top-level public classes, and therefore reused in
   any number of separate test classes.
</p>
<div class="navigation">
   <a href="../tutorial.html"><img align="right" src="go-home.png" title="Contents"></a>
   <a href="StateBasedTesting.html"><img align="right" src="go-next.png" title="Next chapter"></a>
   <a href="RunningTests.html"><img align="right" src="go-previous.png" title="Previous chapter"></a>
</div>
<br/>
</body>
</html>
