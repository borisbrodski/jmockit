<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>JMockit installation instructions</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <link rel="stylesheet" type="text/css" href="prettify.css"/>
</head>
<body>

<h2>
   Getting started with the JMockit Testing Toolkit
   <a href="http://code.google.com/p/jmockit"><img align="right" src="tutorial/go-home.png" title="JMockit Home"></a>
</h2>
<p>
   Available toolkit artifacts include a full distribution zip file as well as binary and source
   jars in a public Maven 2 repository.
   The toolkit is documented through a tutorial, API documentation, and several sample test suites.
</p>

<h3>Using the JMockit full distribution</h3>
<p>
   Follow these instructions to start using JMockit:
</p>
<ol>
   <li>
      Download the <a href="http://code.google.com/p/jmockit/downloads/list?q=label:Featured">full
      distribution</a> for the latest release.
   </li>
   <li>
      Unpack the zip file to any directory.
      This will create the <code>jmockit</code> directory containing the library jars and source,
      samples, Javadocs and additional documentation.
   </li>
   <li>
      Add the library file <strong><code>jmockit.jar</code></strong> to your classpath (in your Java
      IDE project, Ant build file, and so on, as required).
      Verify that this file appears <em>before</em> any JUnit jar file in the classpath
      (this isn't required, but it will provide the greatest ease of use).
   </li>
   <li>
      If you are using a JDK of version 1.6 or newer on Mac OS X, or a non-Sun JDK such as the IBM
      J9 JDK or the JRockit JDK, also add <strong><code>&lt;jdkDir>/lib/tools.jar</code></strong> to
      the classpath (<code>&lt;jdkDir></code> is the home directory for your local JDK 1.6
      installation).
      This second jar file isn't required, but it avoids the need to specify the initialization
      parameter <code>-javaagent:jmockit.jar</code> to the JVM when running tests.
      When using a Sun JDK 1.6+ on Windows or Linux, adding this extra jar file to the classpath is
      unnecessary.
   </li>
   <li>
      Optionally, configure your IDE to find API source code (and consequently the associated
      Javadoc comments) in this same <code>jmockit.jar</code> file.
      API documentation in HTML is also available in the <code>jmockit/www/javadoc</code> directory,
      as well as
      <a href="http://jmockit.googlecode.com/svn/trunk/www/javadoc/overview-summary.html">on-line</a>.
   </li>
</ol>

<h3>Using JMockit in a Maven project</h3>
<p>
   The JMockit artifacts, including a binary jar and a sources jar for each release, are located in
   the <a href="http://download.java.net/maven/2/">Java.net Maven 2 Repository</a>.
   Therefore, you might need to add the following to your Maven configuration:
</p>
<pre>
      &lt;repository>
         &lt;id>maven2-repository.dev.java.net&lt;/id>
         &lt;name>Java.net Repository for Maven&lt;/name>
         &lt;url>http://download.java.net/maven/2/&lt;/url>
      &lt;/repository>
</pre>
<p>
   For any project containing JMockit tests, add the following dependency to the
   <code>pom.xml</code> file:
</p>
<pre>
      &lt;dependency>
         &lt;groupId>mockit&lt;/groupId>
         &lt;artifactId>jmockit&lt;/artifactId>
         &lt;version>0.994&lt;/version>
         &lt;scope>test&lt;/scope>
      &lt;/dependency>
</pre>
<p>
   This dependency should come <em>before</em> the <code>junit</code> dependency, if any.
</p>
<p>
   If using JDK 1.6 on Mac OS X or a non-Sun JDK 1.6, you will probably also want to have the
   following dependency in your project:
</p>
<pre>
      &lt;dependency>
         &lt;groupId>com.sun&lt;/groupId>
         &lt;artifactId>tools&lt;/artifactId>
         &lt;version>1.6.0&lt;/version>
         &lt;scope>system&lt;/scope>
         &lt;systemPath>${java.home}/../lib/tools.jar&lt;/systemPath>
      &lt;/dependency>
</pre>
<p>
   This dependency is <em>not</em> needed in a Windows or Linux environment when using a Sun JDK
   1.6+.
</p>
<p>
   For information on using JMockit Coverage with Maven, see the
   <a href="tutorial/CodeCoverage.html#maven">relevant section</a> in the JMockit Tutorial.
</p>

<h3>Using the mocking APIs</h3>
<p>
   The JMockit mocking APIs can be used in tests written with any of the popular testing frameworks:
   JUnit 3.8, JUnit 4 (version 4.5 or newer) and TestNG (version 5.8 or newer).
   Lets now see how mocking is done with the available JMockit APIs, which are all imported from the
   <code>mockit</code> package.
</p>

<h4>Creating a mock object</h4>
<p>
   In a test class, simply declare a <em>mock field</em> of the desired type, annotated as
   <code>@Mocked</code>.
</p>
<pre><code>import org.junit.*;
import mockit.*;

public class MyFirstJMockitTest
{
   @Mocked Collaborator mock1;
   @Mocked AnotherDependency anotherMock;

   @Test
   public void myFirstTestMethod()
   {
      // Mock objects that are in scope can be used here.
   }

   @Test
   public void anotherTestMethod(YetAnotherDependency testSpecificMock)
   {
      ...
   }

   ...
}
</code></pre>
<p>
   The template test class above shows something unusual: the second test method actually declares a
   parameter! Normally, JUnit (and TestNG) test methods are not allowed to have parameters.
   When using JMockit, however, such <em>mock parameters</em> are allowed and quite useful.
   In fact, it's best to use mock fields of the test class only when the mocked types are needed by
   most or all tests in the class. Otherwise, mock parameters (or <em>local mock fields</em>, which
   we introduce later) with scope limited to a single test are preferred.
   JMockit will always take care of instantiating the mocked type and either assigning the instance
   to the mock field (provided the field is not <code>final</code>) or passing it as an argument
   when the test method is invoked by the test runner.
</p>
<p>
   Although optional, mock parameters can also be annotated with <code>@Mocked</code>.
   Instance fields of the test class which are <em>not</em> annotated, on the other hand, will not
   be mocked. Therefore, the use of <code>@Mocked</code> for <em>mock</em> fields of the test class
   is required.
</p>

<h4>What exactly goes inside a test method?</h4>
<p>
   The following template shows the basic structure of a JMockit test method, when using the
   <em>Expectations & Verifications API</em> for <em>behavior-based</em> testing:
</p>
<pre><code>   @Test
   public void aTestMethod()
   {
      // <em>Record phase</em>: expectations on mocks are recorded; this can actually be empty.

      // <em>Replay phase</em>: invocations on mocks are "replayed"; here the code under test is exercised.

      // <em>Verify phase</em>: expectations on mocks are verified; this also can be empty.
   }
</code></pre>
<p>
   Each test method can be divided in three <em>execution phases</em>.
   First, one or more invocations on mock objects are <em>recorded</em>.
   (In fact, it is perfectly valid to not record any invocation at all - more on this later.)
   Second, the production code/class/unit which our test method is supposed to test is exercised,
   typically with a call to a single tested method. Any invocations to mocks that were previously
   recorded will now have a chance to be <em>replayed</em>.
   Third, the test method can explicitly <em>verify</em> that specific invocations to mock objects
   used in the test actually happened (or not) during replay. Again, it is perfectly valid for this
   phase to be empty, with no explicit verifications (but with <em>implicit</em>, automatic,
   verifications - otherwise no behavior would be tested).
</p>

<h4>Recording expectations</h4>
<p>
   In the record phase of a test, we write one or more <em>expectation blocks</em>, inside which
   invocations to mocked types are recorded.
</p>
<p>
<pre><code>   @Test
   public void aTestMethod()
   {
      new NonStrictExpectations()
      {
         MyCollaborator mock;

         {
            mock.getData(); returns("my test data");
            mock.doSomething(anyInt, "some expected value", anyString); repeats(1);
         }
      };

      // In the replay phase, the tested method would somehow call the "getData" and "doSomething"
      // methods on a "MyCollaborator" instance.
      ...

      // In the verify phase, we may optionally verify expected invocations to "MyCollaborator"
      // objects.
      ...
   }
</code></pre>
<p>
   There are two classes that can be used to define "expectation blocks": <code>Expectations</code>
   and <code>NonStrictExpectations</code>.
   The difference is only in the default behavior for the recorded expectations.
   In the first case, all expectations associated to mocked types used in the block will be
   <em>strict</em> by default, meaning that the invocations are <em>expected</em> to occur in the
   replay phase in the same order as they were recorded, and that invocations not recorded are
   <em>not expected</em> to occur.
   In the second case, expectations are always <em>non-strict</em>, meaning that the invocations to
   mocked types, whether recorded or not, are <em>allowed</em> to occur in any order and in any
   number, including not at all.
</p>

<h4>Verifying expectations</h4>
<p>
   The smart reader probably already figured out why and when we would have a non-empty verification
   phase in a test.
   It boils down to the existence or not of non-strict expectations in the test.
   If all mocked types used in the test have only strict expectations, then all invocations will be
   implicitly and automatically verified at the end of the test. In this case, there will be no
   explicit verify phase.
   If there is at least one mocked type with non-strict expectations, then we can use one or more
   <em>verification blocks</em> to make sure that the invocations we care about actually occurred
   during the replay phase.
</p>
<pre><code>   @Test
   public void aTestMethod(final MyCollaborator mock)
   {
      // Non-strict expectations were recorded, or perhaps there are no expectation blocks at all.

      // Code under test is exercised:
      ...

      new Verifications()
      {
         {
            // Here we verify that the "MyCollaborator#doSomething()" method was executed at least once:
            mock.doSomething();

            // Another verification, which must have occurred no more than three times:
            mock.someOtherMethod(anyBoolean, any, withInstanceOf(Xyz.class)); repeatsAtMost(3);
         }
      };
   }
</code></pre>

<h4>More information</h4>
<p>
   The examples above give only a brief overview of the available mocking APIs. There is much more.
   The full <a href="tutorial.html">JMockit Tutorial</a> contains an extensive discussion of nearly
   all methods, annotations, etc., with many examples.
   The <a href="javadoc/overview-summary.html">API documentation</a> provides a detailed
   specification for all elements of the mocking APIs.
   Finally, there are hundreds of JUnit <a href="samples.html">sample tests</a> available under the
   <code>jmockit/samples</code> folder, which use nearly everything that is available in the APIs.
</p>

<script type="text/javascript" src="prettify.js"></script>
</body>
</html>
