<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <title>JMockit installation instructions</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <link rel="stylesheet" type="text/css" href="prettify.css"/>
</head>
<body>

<h2>
   Getting started with the JMockit Testing Toolkit
   <a href="http://code.google.com/p/jmockit"><img align="right" src="tutorial/go-home.png" title="JMockit Home"></a>
</h2>
<p>
   Available toolkit artifacts include a full distribution zip file as well as binary and source
   jars in a public Maven 2 repository.
   The toolkit is documented through a tutorial, API documentation, and several sample test suites.
</p>

<h3>Using the JMockit full distribution</h3>
<p>
   Follow these instructions to start using JMockit:
</p>
<ol>
   <li>
      Download the <a href="http://code.google.com/p/jmockit/downloads/list?q=label:Featured">full
      distribution</a> for the latest release.
   </li>
   <li>
      Unpack the zip file to any directory.
      This will create the <code>jmockit</code> directory containing the library jars and source,
      samples, Javadocs and additional documentation.
   </li>
   <li>
      Add the library file <strong><code>jmockit.jar</code></strong> to your classpath (in your Java
      IDE project, Ant build file, and so on, as required).
      Verify that this file appears <em>before</em> any JUnit jar file in the classpath
      (this isn't required, but it will provide the greatest ease of use).
   </li>
   <li>
      Depending on your development environment, you <em>may</em> have to do one of two other
      things:
      <ul>
         <li>
            If you are developing on JDK 1.5, then make sure that
            <code>-javaagent:jmockit.jar</code> (with the proper absolute or relative path to
            <code>jmockit.jar</code>) is passed as an initialization parameter to the JVM when
            running tests.
            This standard JVM initialization parameter causes it to load on start-up the
            "Java agent" that JMockit uses internally for bytecode instrumentation; this is required
            to work in all standard JVMs since version 1.5, in all OSs.
            You may also have to use this parameter on a newer JDK 1.6+, if for some reason the
            second option described below doesn't work as expected (as is currently the case with
            the IBM J9 JDK 1.6).
         </li>
         <li>
            If you are developing on a JDK of version 1.6 or newer on Mac OS X, add
            <strong><code>&lt;jdkDir>/lib/tools.jar</code></strong> to the classpath, where
            <code>&lt;jdkDir></code> is the home directory for your local JDK 1.6 installation.
         </li>
      </ul>
      When using a Sun HotSpot JDK 1.6+ or an Oracle JRockit JDK 1.6+ on Windows or Linux, neither
      of the extra steps above is necessary.
   </li>
   <li>
      Optionally, configure your IDE to find API source code (and consequently the associated
      Javadoc comments) in this same <code>jmockit.jar</code> file.
      API documentation in HTML is also available in the <code>jmockit/www/javadoc</code> directory,
      as well as
      <a href="http://jmockit.googlecode.com/svn/trunk/www/javadoc/overview-summary.html">on-line</a>.
   </li>
</ol>

<h4>Running tests in Eclipse with the JUnit plug-in</h4>
<p>
   The JUnit plug-in available in the Eclipse Java IDE provides a version of <code>junit.jar</code>
   which does not work with JMockit (the plug-in itself does work).
   The problem is that, contrary to the
   <a href="http://github.com/KentBeck/junit/downloads">official JUnit jars</a>, the
   <code>junit.jar</code> file that comes with the Eclipse installation is
   <a href="http://wiki.eclipse.org/JAR_Signing#Should_third_party_JARs_be_signed.3F">signed</a>.
   This prevents JMockit from starting itself up correctly. The workaround is to use a regular
   (non-signed) JUnit jar file instead, which in Eclipse can be added to the classpath directly or
   as part of a "User Library".
</p>

<h3>Using JMockit in a Maven project</h3>
<p>
   The JMockit artifacts, including a binary jar and a sources jar for each release, are located in
   the <a href="http://download.java.net/maven/2/">Java.net Maven 2 Repository</a>.
   Therefore, you might need to add the following to your Maven configuration:
</p>
<pre>
      &lt;repository>
         &lt;id>maven2-repository.dev.java.net&lt;/id>
         &lt;name>Java.net Repository for Maven&lt;/name>
         &lt;url>http://download.java.net/maven/2/&lt;/url>
      &lt;/repository>
</pre>
<p>
   For any project containing JMockit tests, add the following dependency to the
   <code>pom.xml</code> file:
</p>
<pre>
      &lt;dependency>
         &lt;groupId>mockit&lt;/groupId>
         &lt;artifactId>jmockit&lt;/artifactId>
         &lt;version>0.995&lt;/version>
         &lt;scope>test&lt;/scope>
      &lt;/dependency>
</pre>
<p>
   This dependency should come <em>before</em> the <code>junit</code> dependency, if any.
</p>
<p>
   To run tests with JDK 1.5, you will need to make sure the JVM is started with the
   <code>-javaagent</code> initialization parameter. This can be done in the Maven Surefire plug-in
   as follows:
</p>
<pre>
      &lt;plugin>
         &lt;artifactId>maven-surefire-plugin&lt;/artifactId>
         &lt;configuration>
            &lt;argLine>-javaagent:"${settings.localRepository}"/mockit/jmockit/0.995/jmockit-0.995.jar&lt;/argLine>
         &lt;/configuration>
      &lt;/plugin>
</pre>
<p>
   Note that the above JVM parameter is not required when using JDK 1.6 (or newer) to run tests.
   Even if you have to deploy production code in a JDK 1.5 environment, consider using JDK 1.6 in
   your local development environment; with the proper build/IDE configuration, a JDK 1.6 Java
   compiler (either "javac" or the Eclipse compiler) can safely be used to compile Java 1.5 code
   while generating Java 1.5-compliant class files.
</p>
<p>
   If using JDK 1.6 on Mac OS X, you should have the following extra dependency in your project:
</p>
<pre>
      &lt;dependency>
         &lt;groupId>com.sun&lt;/groupId>
         &lt;artifactId>tools&lt;/artifactId>
         &lt;version>1.6.0&lt;/version>
         &lt;scope>system&lt;/scope>
         &lt;systemPath>${java.home}/../lib/tools.jar&lt;/systemPath>
      &lt;/dependency>
</pre>
<p>
   This dependency is <em>not</em> needed in a Windows or Linux environment when using a Sun HotSpot
   JDK 1.6+ or an Oracle JRockit JDK 1.6+.
</p>
<p>
   For information on using JMockit Coverage with Maven, see the
   <a href="tutorial/CodeCoverage.html#maven">relevant section</a> in the JMockit Tutorial.
</p>

<h3>Using the mocking APIs</h3>
<p>
   The JMockit mocking APIs can be used in tests written with any of the popular testing frameworks:
   JUnit 3.8, JUnit 4 (version 4.5 or newer) and TestNG (version 5.8 or newer).
   Lets now see how mocking is done with the available JMockit APIs, which are all imported from the
   <code>mockit</code> package.
</p>

<h4>Creating a mock object</h4>
<p>
   In a test class, simply declare a <em>mock field</em> of the desired type, annotated as
   <code>@Mocked</code>.
</p>
<pre><code>import org.junit.*;
import mockit.*;

public class MyFirstJMockitTest
{
   @Mocked Collaborator mock1;
   @Mocked AnotherDependency anotherMock;

   @Test
   public void myFirstTestMethod()
   {
      // Mock objects that are in scope can be used here.
   }

   @Test
   public void anotherTestMethod(YetAnotherDependency testSpecificMock)
   {
      ...
   }

   ...
}
</code></pre>
<p>
   The template test class above shows something unusual: the second test method actually declares a
   parameter! Normally, JUnit (and TestNG) test methods are not allowed to have parameters.
   When using JMockit, however, such <em>mock parameters</em> are allowed and quite useful.
   In fact, it's best to use mock fields of the test class only when the mocked types are needed by
   most or all tests in the class. Otherwise, mock parameters (or <em>local mock fields</em>, which
   we introduce later) with scope limited to a single test are preferred.
   JMockit will always take care of instantiating the mocked type and either assigning the instance
   to the mock field (provided the field is not <code>final</code>) or passing it as an argument
   when the test method is invoked by the test runner.
</p>
<p>
   Although optional, mock parameters can also be annotated with <code>@Mocked</code>.
   Instance fields of the test class which are <em>not</em> annotated, on the other hand, will not
   be mocked. Therefore, the use of <code>@Mocked</code> for <em>mock</em> fields of the test class
   is required.
</p>

<h4>What exactly goes inside a test method?</h4>
<p>
   The following template shows the basic structure of a JMockit test method, when using the
   <em>Expectations & Verifications API</em> for <em>behavior-based</em> testing:
</p>
<pre><code>   @Test
   public void aTestMethod()
   {
      // <em>Record phase</em>: expectations on mocks are recorded; this can actually be empty.

      // <em>Replay phase</em>: invocations on mocks are "replayed"; here the code under test is exercised.

      // <em>Verify phase</em>: expectations on mocks are verified; this also can be empty.
   }
</code></pre>
<p>
   Each test method can be divided in three <em>execution phases</em>.
   First, one or more invocations on mock objects are <em>recorded</em>.
   (In fact, it is perfectly valid to not record any invocation at all - more on this later.)
   Second, the production code/class/unit which our test method is supposed to test is exercised,
   typically with a call to a single tested method. Any invocations to mocks that were previously
   recorded will now have a chance to be <em>replayed</em>.
   Third, the test method can explicitly <em>verify</em> that specific invocations to mock objects
   used in the test actually happened (or not) during replay. Again, it is perfectly valid for this
   phase to be empty, with no explicit verifications (but with <em>implicit</em>, automatic,
   verifications - otherwise no behavior would be tested).
</p>

<h4>Recording expectations</h4>
<p>
   In the record phase of a test, we write one or more <em>expectation blocks</em>, inside which
   invocations to mocked types are recorded.
</p>
<p>
<pre><code>   @Test
   public void aTestMethod()
   {
      new NonStrictExpectations()
      {
         MyCollaborator mock;

         {
            mock.getData(); <em>result</em> = "my test data";
            mock.doSomething(<em>anyInt</em>, "some expected value", <em>anyString</em>); <em>times</em> = 1;
         }
      };

      // In the replay phase, the tested method would somehow call the "getData" and "doSomething"
      // methods on a "MyCollaborator" instance.
      ...

      // In the verify phase, we may optionally verify expected invocations to "MyCollaborator"
      // objects.
      ...
   }
</code></pre>
<p>
   There are two classes that can be used to define "expectation blocks": <code>Expectations</code>
   and <code>NonStrictExpectations</code>.
   The difference is only in the default behavior for the recorded expectations.
   In the first case, all expectations associated to mocked types used in the block will be
   <em>strict</em> by default, meaning that the invocations are <em>expected</em> to occur in the
   replay phase in the same order as they were recorded, and that invocations not recorded are
   expected to <em>not</em> occur.
   In the second case, expectations are always <em>non-strict</em>, meaning that the invocations to
   mocked types, whether recorded or not, are <em>allowed</em> to occur in any order and in any
   number, including not at all.
</p>
<p>
   You may be wondering what are those field assignments doing there.
   The <em><code>result</code></em> field takes the desired return value for the preceding
   invocation, while <em><code>times</code></em> takes the number of times the preceding invocation
   is allowed and expected to occur.
   (There is also a <em><code>minTimes</code></em> and a <em><code>maxTimes</code></em> field.)
   The <em><code>result</code></em> field also accepts a <code>Throwable</code> instance, which
   would cause the corresponding invocation in the replay phase to throw the specified exception or
   error.
   Each of these special fields has an equivalent method that could be used instead:
   <code>returns(...)</code>, <code>repeats(n)</code>, <code>throwsException(...)</code>, etc;
   but the fields are nicer.
</p>

<h4>Verifying expectations</h4>
<p>
   The smart reader probably already figured out why and when we would have a non-empty verification
   phase in a test.
   It boils down to the existence or not of non-strict expectations in the test.
   If all mocked types used in the test have only strict expectations, then all invocations will be
   implicitly and automatically verified at the end of the test. In this case, there will be no
   explicit verify phase.
   If there is at least one mocked type with non-strict expectations, then we can use one or more
   <em>verification blocks</em> to make sure that the invocations we care about actually occurred
   during the replay phase.
</p>
<pre><code>   @Test
   public void aTestMethod(final MyCollaborator mock)
   {
      // Non-strict expectations were recorded, or perhaps there are no expectation blocks at all.

      // Code under test is exercised:
      ...

      new Verifications()
      {
         {
            // Here we verify that the "MyCollaborator#doSomething()" method was executed at least once:
            mock.doSomething();

            // Another verification, which must have occurred no more than three times:
            mock.someOtherMethod(<em>anyBoolean</em>, <em>any</em>, withInstanceOf(Xyz.class)); <em>maxTimes</em> = 3;
         }
      };
   }
</code></pre>

<h4>State-oriented mocking</h4>
<p>
   Sometimes you are more interested in checking the argument values passed to a mocked
   collaborator, instead of checking that the invocation to the collaborator was made from the
   client/tested method.
   Of course, you <em>can</em> check argument values through a recorded or verified expectation, but
   it becomes more difficult when those values are complex.
   In such cases it may be easier to use the <code>mockit.MockUp&lt;T></code> generic class, as the
   next test shows.
</p>
<pre><code>   @Test
   public void stateBasedTestMethod()
   {
      new MockUp&lt;MyCollaborator>()
      {
         @Mock(invocations = 1) // (the invocation count constraint is optional)
         boolean doSomething(int n, String s, ComplexData otherData)
         {
            assertEquals(1, n);
            assertNotNull(otherData);
            ...
            // Return (if non-void) or throw the desired result the invocation to
            // the mocked method should produce:
            return otherData.isValid();
         }
   
         // Other mock or regular methods...
      };

      // Exercise the code under test normally; calls to MyCollaborator#doSomething will execute
      // the mock method above; if more or less than one such invocation occurs, the test fails.
      ...
   }
</code></pre>
<p>
   The <code>@Mock</code> annotation marks those methods in the <em>mock-up class</em> which are
   supposed to provide mock/stub implementations for the corresponding methods (of the same
   signature) in the mocked class.
</p>

<h4>More information</h4>
<p>
   The examples above give only a brief overview of the available mocking APIs. There is much more.
   The full <a href="tutorial.html">JMockit Tutorial</a> contains an extensive discussion of nearly
   all methods, annotations, etc., with many examples.
   The <a href="javadoc/overview-summary.html">API documentation</a> provides a detailed
   specification for all elements of the mocking APIs.
   Finally, there are hundreds of JUnit <a href="samples.html">sample tests</a> available under the
   <code>jmockit/samples</code> folder, which use nearly everything that is available in the APIs.
</p>

<script type="text/javascript" src="prettify.js"></script>
</body>
</html>
